## 1、自定义泛型结构

自定义泛型类

```java
//如果定义了泛型类，实例化时没有指定泛型就默认为Object
public class Generic<T> {

    T key;
    T value;

    public Generic() {

    }
    public Generic(T key, T value) {
        this.key = key;
        this.value = value;
    }

}
```

自定义泛型子类

```java
//当继承时如果父类已经指明了泛型类型，则实例化子类对象时不再需要声明泛型
public class SubGeneric extends Generic<String> {
        
}
//当继承时如果父类未指明泛型类型，子类需保留父类中未指定的泛型：可全部保留，可部分保留
public class SubGeneric2<T> extends Generic<T> {
}
```

- tips：泛型如果不指定，将被擦除，泛型对应的类型一律按照Object处理，但是不等价于Object。经验：泛型要么就一直用，要么就不用。

- 泛型不能在static方法里使用，因为static方法是类的，泛型是需要类在实例化时被指定的。
- 异常类不能声明为泛型类

## 2、自定义泛型方法

**泛型方法不是指方法中使用了泛型的类，而是指方法中使用了泛型的结构**

自定义泛型方法

```java
//泛型方法在调用时，指明泛型参数的类型
public <E>List<E> genericMethod(E[] arr) {

    return new ArrayList<E>();
}
```

- 泛型方法可以为static方法，因为泛型参数是在泛型方法调用的时候传入的

## 3、泛型应用

情境：数据库中有多个表，每个表对应着一个DAO，你需要首先定义一个父类DAO

```java
public class DAO<T> {
    //add
    public void add(T t){
    }
}
```

然后写子类DAO

```java
public class XxxxxDAO extends DAO<Xxxxx> {
}

public class Xxxxx {
    int value;
}
```

测试

```java
public static void main(String[] args) {
    Xxxxx xxxxx = new Xxxxx();
    XxxxxDAO xxxxxDAO = new XxxxxDAO();
    xxxxxDAO.add(xxxxx);
}
```

## 4、泛型在继承的体现

- 虽然类A是类B的父类，但是G<A>和G<B>二者不具备子父类关系，两者是并列关系 ，而A<G>和B<G>是子父类关系

下列代码中，lo和ls不具有子父类关系，因此不能直接赋值

```java
Object o = new Object();
String s = new String();
o = s;

Object[] os = new Object[2];
String[] ss = new String[2];
os = ss;

List<Object> lo = null;
List<String> ls = null;
//lo和ls的类是同级关系，跟里面的泛型并没有关系 
lo = ls;  //编译不通过
```

## 5、通配符的使用

通配符为？，能表示任何泛型，作为一个通用父类存在。

```java

public static void main(String[] args) {

    List<String> l1 = null;
    List<Object> l2 = null;
	//可以等于l1，也可以等于l2
    List<?> l = null;
    l = l1;
    l = l2;
    print(l1);
    print(l2);

}
//通配符打印
public static void print(List<?> l) {
    Iterator<?> iterator = l.iterator();
    while (iterator.hasNext()) {
        Object next = iterator.next();
        System.out.println(next);
    }

}
```

- 注意：使用通配符后的list不能再add元素，get到的元素返回为Object

#### 有限制条件的通配符使用

- ? extends Person：通配符表示Person以及Person的子类
- ? super Person：通配符表示Person以及Person的父类