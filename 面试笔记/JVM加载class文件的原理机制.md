---
title: JVM加载class文件的原理机制
tags: Java基础
categories: Java面试之Java基础
description: 本文描述了JVM的组成部分，以及JVM中类加载器加载class文件的原理机制
---

## 1、JVM

JVM 全称是Java Virtual Machine ，翻译过来就是Java 虚拟机，下图是JVM的组成部分。

![](http://fl.ljuuu.com/img/690102-20160726145530263-378108880.png)

- Class Loader(类加载器)：**类加载器本身也是一个类**。当Java源代码(.java)经过javac的编译之后变成了字节码(.class)，字节码会进入JVM的类加载器。但是，并不是所有的字节码文件进入类加载器之后都会被加载，而是必须符合class文件的格式要求才会被加载。但是加载之后能不能运行就不是类加载器的负责部分了。
- Runtime Data Area(运行数据区)：
  - PC Register(程序计数器)：这部分是一块较小的内存空间，它可以被看成当前线程所执行的字节码的行号指示器。简单来说，就是为了保证程序的正确运行。当存在多线程时，CPU将线程A挂起并且去执行线程B，然后又回来执行线程A，此时CPU怎么知道之前该线程执行到哪里呢？因此，我们需要给每个线程都分配一个程序计数器，来记录该线程执行到的字节码行数，因此，**每个程序计数器都是线程私有的。**
  - Stack(Java虚拟机栈)：**Java虚拟机栈是线程私有的，生命周期与线程相同。**它的存在是为了存储字节码文件解释时Java方法产生的内存模型。每个方法被执行时都会产生一个**栈帧**，存储局部变量表、操作栈、动态链接、方法出口。每个方法被调用到执行完成的过程，就相当于该栈帧在Java虚拟机栈从入栈到出栈的一次过程。
  - Heap(Java虚拟机堆)：Java虚拟机堆是虚拟机内存中最大的一部分，它在JVM启动时创建，被**所有线程所共享**。它负责存放对象实例，而**Java的GC机制主要管理的也就是Java虚拟机堆**。Java虚拟机堆在物理上可以不连续，逻辑上连续即可。
  - Method Area(方法区)：**方法区域Java虚拟机堆一样，是线程共享的，并且也是可以在物理上不连续，逻辑上连续即可。**这个区域存储一些已经被JVM加载的类信息、常量、静态变量等。方法区包括Runtime Constant Pool(运行时常量池)，它是用于保存 Class 文件中的符号引用、翻译出来的直接引用。
  - Native Method Stack(本地方法栈)：**本地方法栈也是线程私有的。**与Java虚拟机栈类似，只不过Java虚拟机栈中的方法是字节码文件解释时产生的Java方法，而本地方法栈中的方法是本地方法。
- Execution Engine(执行引擎)：我们知道Java的跨平台性是因为JVM的存在，JVM中执行引擎的作用就相当于解释器，将字节码文件解释成机器码。
- Native Interface(本地库接口)：当执行引擎在解释时，需要加载一些基本类库，本地库接口的作用就是提供基本类库的接口给其引用。

## 2、JVM加载class文件的原理机制

了解了JVM的组合和体系，我们就很容易理解JVM加载class文件的原理机制

类加载器加载过程：

- 装载和导入字节码文件
- 链接：
  - 检查：检查字节码文件的格式
  - 准备：为类的静态变量分配内存
  - 解析：将符号引用转化成直接引用
- 初始化：初始化静态变量，静态代码块

























