---
title: 详解HashMap、HashTable、HashSet
tags: 数据结构
categories: Java面试之数据结构与算法
description: 对HashMap和HashSet进行了详解，同时比较了HashMap和HashTable的区别。
---

## 1、HashMap详解

### 1.1、简介

- HashMap是基于哈希表的Map实现。
- 哈希表是一种数据结构，HashMap是基于哈希表实现的，哈希表由数组＋链表组成(**JDK8引入了红黑树**)。
- 哈系表的主干是数组，其存储的值是Node<K,V>结点，值在数组中的存储位置由键取哈希之后得到，因为HashMap是通过键来查找值，而查找值只需要将键计算一次哈希值便可以找到值的存储位置，因此其查找效率为O(1)。
- 然而通过哈希函数计算的哈希值并不是不相等的，有可能输入不同的键而计算出相同的哈希值，这就是哈希冲突。HashMap解决哈希冲突的方法就是引入链表，每个数组存储的元素为一个单链表，当发生哈希冲突的时候便把将这些冲突的元素存储为一条链表，JDK8之前单链表不会转化成红黑树，这导致一旦单链表长了之后，查找效率就会变低；JDK8之后引入红黑树，当单链表长度超过某个阈值之后转化成红黑树，使查找效率变高。

### 1.2、关系

​	首先我们来了解一下java.util.Map这个接口，这个接口十分强大，在源码中HashMap继承了AbstractMap这个父类，而HashMap和AbstractMap都实现了java.util.Map这个接口，另外两种数据结构LinkedHashMap和TreeMap，LinkedHashMap继承了HashMap，TreeMap继承了AbstractMap，这两种数据结构本文暂时先不介绍。

### 1.3、详解

- 哈希算法：
  - `hashcode()`：哈希函数会对键`key`进行`hashcode()`得到它的哈希值。
  - 高位运算：将哈希值与数组长度进行按位与(&)运算，得到存储位置。JDK8之后优化了高位运算，通过hashCode()的高16位异或低16位实现按位与(&)。
  - 取模运算：将哈希值与数组长度进行取模运算，得到存储位置

- `get()`方法实现：
  - 首先获取输入的键`key`，调用其`hashcode()`方法计算它的哈希值，然后通过哈希算法的后两步运算(**高位运算与取模运算**)计算出这个键对应的值的哈希表的存储地址。
  - 如果这个存储地址为null，则返回null；如果这个地址存储的为单链表，那么就遍历这个单链表，将`key`与单链表每个元素的键进行`equals()`，查找到则返回元素，否则返回null；如果这个地址存储的为红黑树，则调用红黑树的查找方法实现。
- `put()`方法实现：
  - 将输入的键`key`和值`value`封装成`Node<key,value>`结点。
  - 调用键的`hashcode()`方法计算出它的哈希值，然后通过哈希算法的后两步运算(**高位运算与取模运算**)计算出这个键对应的值的哈希表的存储地址。
  - 如果这个存储地址为null，则直接将这个结点存储在这个地址；如果这个存储地址存储的为一个单链表，则将`key`与单链表每个元素的键进行`equals()`，若全部都返回false，则**将该结点存储在单链表尾部(注：JDK8以前是存储在链表头部)**，若存储true，则覆盖原来的元素。如果是红黑树则调用红黑树的添加结点的方法。
  - 单链表存储完结点之后，会判断当前单链表长度是否大于等于8，当大于等于8时，则单链表会转化成红黑树。
- 扩容机制：
  - 哈希表初始化时的数组大小为16，负载因子为0.75，当哈希表中元素个数大于16*0.75个时，会触发哈希表的自动扩容机制，自动扩容之后数组大小为原来的两倍。
  - 扩容过程会创建长度为原来两倍的数组，调用transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。**JDK8之后优化了扩容过程，8之后扩容不需要重新计算哈希值(rehash的代价真的很大)，并且链表元素不会倒置。**
- 单链表与红黑树的相互转化：
  - 单链表转化红黑树：当哈希表同一个hashcode值下，数据个数大于等于8个时，即单链表长度大于等于8时，会将单链表转化成红黑树。为什么阈值是8呢？因为链表中的节点遵循泊松分布，而且根据统计，链表中节点数是8的概率已经接近千万分之一，此时单链表的性能已经很差了，因此，转化为红黑树。
  - 红黑树退化成单链表：当红黑树结点小于等于6个时，红黑树退化成单链表。阈值为6而不为8的原因是避免红黑树与单链表频繁的转化。

### 1.4、线程安全性

- 在多线程使用场景中，应该尽量避免使用线程不安全的HashMap，而使用线程安全的ConcurrentHashMap。
- put数据不一致：A线程得到某个表头结点时，B线程开始并写入数据，而切换回A线程时A使用的是原来取出的表头，这就使B线程写入的数据消失了。
- Rehash出现死循环：
  - 假设HashMap初始化大小为2，插入个2节点，不巧的是，这2个节点都hash到同一个位置，为a->b。插入第二个节点的时候会进行扩容。
  - 线程A和B都需要进行扩容，然后当线程A执行到`Entry<K,V> next = e.next`时，next=a，e=b，然后线程A被挂起，执行线程B
  - 线程B执行完扩容之后，刚好这两个节点又hash到同一个地址，此时存储的就是b->a，因此是头插法。
  - 线程A被唤醒，首先将b插入扩容后的数组，然后再一次执行`Entry<K,V> next = e.next`，此时的e是之前的next，为a。然后把a使用头插法插入链表中。
  - 而此时e的next为b，因为线程B已经扩容完了。
  - 而再插入b，则会使原来a的next变成b，就是数组的头结点，此时就会出现死循环。
- **JDK8之后将头插法变成尾插法，解决了死循环这个问题。**

## 2、HashMap与HashTable区别

- 父类不同：HashMap继承于AbstractMap，而HashTable继承于Dictionary，但是他们两个都实现了Map接口。
- 线程安全性：HashMap中的方法默认是非同步的，因此其线程是不安全的；而HashTable的方法会使用`synchronized`关键字修饰的，因此是线程安全的。
- 是否允许null值：Hashtable中无论是`key`还是`value`都不可以是null值。而在HashMap中，null值可以作为键和值，但是为null的键只能有一个，因此使用`get()`方法返回值为null时，可以表示HashMap中没有这个键值对，也可以表示该键对应的值为null，因此我们一般使用`containsKey()`方法判断HashMap中是否存在某个键。
- ConcurrentHashMap也是线程安全性的，因此可以代替HashTable。但是HashTable提供更强的线程安全性，因为ConcurrentHashMap只会对map的一部分进行上锁。

## 3、HashSet详解

### 1.1、简介

- HashSet是基于HashMap实现的，默认构造函数是构建一个初始容量为16，负载因子为0.75 的HashMap
- 如果我们需要把某个类作为HashSet的键，则必须重写该类的`equals()`和`hashcode()`方法
- HashSet的其他操作都是基于HashMap的。

### 1.2、关系

​	HashSet类继承了AbstractSet这个父类，实现了Set这个接口。

### 1.3、详解

- 为什么要重写`equals()`和`hashcode()`方法：简单来说就是`equals()`方法默认是比较两个对象的内存地址，想要比较值则必须重写`equals()`，而重写`equals()`方法后，则必须重写`hashcode()`，因为`hashcode()`和`equals()`方法返回的结果必须一致，详细参见https://blog.csdn.net/Ferronzhu/article/details/116461427
- 去重原理：去重原理在上面的博客中也有写到。具体来说，HashMap的实现原理就是调用键的`hashcode()`方法计算出其哈希值，然后再经过高位运算和取模运算计算出其在数组中的存储索引。HashSet添加一个键值对时，计算出键的存储索引后，若这个存储索引为null，则存储；若不为null，则进一步调用这两个键的`equals()`方法再次比较，返回true则判断这两个元素相同，不允许存储。这也是为什么HashSet需要保证`hashcode()`与`equals()`方法返回结果相等的原因。
- HashSet不是线程安全的。





