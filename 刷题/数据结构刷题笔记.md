## 20220505：存在重复元素

**题目描述**

给你一个整数数组 `nums` 。如果任一值在数组中出现 **至少两次** ，返回 `true` ；如果数组中每个元素互不相同，返回 `false` 。

**示例**

输入：

```
nums = [1,2,3,1]
```

输出：

```
true
```

**思路分析**

hashset

**代码**

```java
class Solution {
    public boolean containsDuplicate(int[] nums) {

        Set<Integer> set = new HashSet<>();
        for (int num : nums) {
            if (!set.add(num)){
                return true;
            }
        }

        return false;

    }
}
```

## 20220505：最大子数组和

**题目描述**

给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**子数组** 是数组中的一个连续部分。

**示例**

输入：

```
nums = [-2,1,-3,4,-1,2,1,-5,4]
```

输出：

```
6
```

**思路分析**

动态规划

**代码**

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int n = nums.length;
        int max = nums[0];
        int[] dp = new int[n];
        dp[0] = nums[0];
        for (int i = 1; i < n; i++) {
            dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]);
            max = Math.max(max, dp[i]);
        }

        return max;

    }
}
```

## 20220506：两数之和

**题目描述**

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

**示例**

输入：

```
nums = [2,7,11,15], target = 9
```

输出：

```
[0,1]
```

**思路分析**

hashmap

**代码**

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {

        Map<Integer, Integer> map = new HashMap<>();

        for (int i = 0; i < nums.length; i++) {

            int num = nums[i];
            if (map.containsKey(num)) {
                return new int[]{i, map.get(num)};
            }
            map.put(target - nums[i], i);

        }

        return new int[2];

    }
}
```

## 20220506：合并两个有序数组

**题目描述**

给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。

请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。

注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。

**示例**

输入：

```
nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
```

输出：

```
[1,2,2,3,5,6]
```

**思路分析**

思路一：直接排序

思路二：逆序双指针

**代码**

思路一：

```java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {

        for (int i = m; i < m + n; i++) {
            nums1[i] = nums2[i - m];
        }

        Arrays.sort(nums1);

    }
}
```

思路二：

```java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {

        int i = m - 1, j = n - 1;
        for (int k = m + n - 1; k >= 0; k--) {

            if (j < 0) {
                nums1[k] = nums1[i--];
            } else if (i < 0) {
                nums1[k] = nums2[j--];
            } else if (nums1[i] >= nums2[j]) {
                nums1[k] = nums1[i--];
            } else {
                nums1[k] = nums2[j--];
            }
        }

    }
}
```

## 20220507：两个数组的交集II

**题目描述**

给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。

**示例**

输入：

```
nums1 = [1,2,2,1], nums2 = [2,2]
```

输出：

```
[2,2]
```

**思路分析**

hashmap

**代码**

```java
class Solution {
    public int[] intersect(int[] nums1, int[] nums2) {

        if (nums1.length < nums2.length) {
            return intersect(nums2, nums1);
        }

        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums2.length; i++) {
            int num = nums2[i];
            int count = map.getOrDefault(num, 0) + 1;
            map.put(num, count);
        }

        int[] res = new int[nums2.length];
        int index = 0;
        for (int i = 0; i < nums1.length; i++) {
            int num = nums1[i];
            int count = map.getOrDefault(num, 0);
            if (count > 0) {
                res[index++] = num;
                count--;
                if (count > 0) {
                    map.put(num, count);
                } else {
                    map.remove(num);
                }
            }

        }



        return Arrays.copyOfRange(res, 0, index);

    }
}
```

## 20220507：买卖股票的最佳时机

**题目描述**

给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

**示例**

输入：

```
[7,1,5,3,6,4]
```

输出：

```
5
```

**思路分析**

动态规划

**代码**

```java
class Solution {
    public int maxProfit(int[] prices) {

        int cost = Integer.MAX_VALUE, max = Integer.MIN_VALUE;

        for (int i = 0; i < prices.length; i++) {

            int price = prices[i];
            cost = Math.min(cost, price);
            max = Math.max(price - cost, max);
        }


        return max;

    }
}
```

## 20220508：重塑矩阵

**题目描述**

在 MATLAB 中，有一个非常有用的函数 reshape ，它可以将一个 m x n 矩阵重塑为另一个大小不同（r x c）的新矩阵，但保留其原始数据。

给你一个由二维数组 mat 表示的 m x n 矩阵，以及两个正整数 r 和 c ，分别表示想要的重构的矩阵的行数和列数。

重构后的矩阵需要将原始矩阵的所有元素以相同的 行遍历顺序 填充。

如果具有给定参数的 reshape 操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。

**示例**

输入：

```
mat = [[1,2],[3,4]], r = 1, c = 4
```

输出：

```
[[1,2,3,4]]
```

**思路分析**

无

**代码**

```java
class Solution {
    public int[][] matrixReshape(int[][] mat, int r, int c) {

        int m = mat.length, n = mat[0].length;
        if (m * n != r * c) {
            return mat;
        }

        int[][] res = new int[r][c];

        int q = 0, p = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                res[q][p++] = mat[i][j];
                if (p == c) {
                    p = 0;
                    q++;
                }

            }
        }
        
        return res;

    }
}
```

## 20220508：杨辉三角

**题目描述**

给定一个非负整数 *`numRows`，*生成「杨辉三角」的前 *`numRows`* 行。

在「杨辉三角」中，每个数是它左上方和右上方的数的和。

**示例**

输入：

```
numRows = 5
```

输出：

```
[[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]
```

**思路分析**

无

**代码**

```java
class Solution {
    public List<List<Integer>> generate(int numRows) {

        List<List<Integer>> res = new ArrayList<>();

        res.add(new ArrayList<Integer>(){{
            add(1);
        }});

        if (numRows == 1) {
            return res;
        }

        for (int i = 1; i < numRows; i++) {
            List<Integer> curList = res.get(i - 1);
            List<Integer> nextList = new ArrayList<>();
            nextList.add(1);
            for (int j = 1; j < curList.size(); j++) {
                int num = curList.get(j) + curList.get(j - 1);
                nextList.add(num);
            }
            nextList.add(1);

            res.add(nextList);
        }

        return res;

    }
}
```

## 20220509：有效的数独

**题目描述**

请你判断一个 9 x 9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。

    数字 1-9 在每一行只能出现一次。
    数字 1-9 在每一列只能出现一次。
    数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）

 注意：

    一个有效的数独（部分已被填充）不一定是可解的。
    只需要根据以上规则，验证已经填入的数字是否有效即可。
    空白格用 '.' 表示。

**示例**

输入：

```
board = 
[["8","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
```

输出：

```
false
```

**思路分析**

分别使用rows数组，cols数组和subboxes数组存储。

**代码**

```java
class Solution {
    public boolean isValidSudoku(char[][] board) {

        int[][] rows = new int[9][9];
        int[][] cols = new int[9][9];
        int[][][] subboxes = new int[3][3][9];

        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {

                char c = board[i][j];
                if (c != '.') {
                    int index = c - '0' - 1;
                    rows[i][index]++;
                    cols[j][index]++;
                    subboxes[i / 3][j / 3][index]++;
                    if (rows[i][index] > 1 || cols[j][index] > 1 || subboxes[i / 3][j / 3][index] > 1) {
                        return false;
                    }

                }

            }
        }


        return true;

    }
}
```

## 20220509：矩阵置0

**题目描述**

给定一个 `*m* x *n*` 的矩阵，如果一个元素为 **0** ，则将其所在行和列的所有元素都设为 **0** 。请使用 **[原地](http://baike.baidu.com/item/原地算法)** 算法**。**

**示例**

输入：

```
matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]
```

输出：

```
[[0,0,0,0],[0,4,5,0],[0,3,1,0]]
```

**思路分析**

无

**代码**

```java
class Solution {
    public void setZeroes(int[][] matrix) {

        int m = matrix.length, n = matrix[0].length;
        Queue<int[]> queue = new LinkedList<>();
        boolean[][] judge = new boolean[m][n];

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (matrix[i][j] == 0) {
                    queue.offer(new int[]{i , j});
                    judge[i][j] = true;
                }
            }
        }

        while (!queue.isEmpty()) {
            int[] x = queue.poll();
            for (int i = 0; i < m; i++) {
                for (int j = 0; j < n; j++) {
                    if ((i == x[0] || j == x[1]) && !judge[i][j]) {
                        matrix[i][j] = 0;
                        judge[i][j] = true;
                    }
                }
            }
        }

    }
}
```

## 20220510：字符串中的第一个唯一字符

**题目描述**

给定一个字符串 `s` ，找到 *它的第一个不重复的字符，并返回它的索引* 。如果不存在，则返回 `-1` 。

**示例**

输入：

```
s = "leetcode"
```

输出：

```
0
```

**思路分析**

hashmap存储

**代码**

```java
class Solution {
    public int firstUniqChar(String s) {

        Map<Character, Integer> map = new HashMap<>();

        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            int num = map.getOrDefault(c, 0) + 1;
            map.put(c, num);
        }

        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (map.get(c) == 1) {
                return i;
            }

        }
        
        return -1;

    }
}
```

## 20220510：赎金信

**题目描述**

给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。

如果可以，返回 true ；否则返回 false 。

magazine 中的每个字符只能在 ransomNote 中使用一次。

**示例**

输入：

```
ransomNote = "a", magazine = "b"
```

输出：

```
false
```

**思路分析**

hashmap

**代码**

```java
class Solution {
    public boolean canConstruct(String ransomNote, String magazine) {

        Map<Character, Integer> map = new HashMap<>();

        for (int i = 0; i < magazine.length(); i++) {

            char c = magazine.charAt(i);
            int num = map.getOrDefault(c, 0) + 1;
            map.put(c, num);

        }

        for (int i = 0; i < ransomNote.length(); i++) {

            char c = ransomNote.charAt(i);
            if (!map.containsKey(c) || map.get(c) < 1) {
                return false;
            }
            int num = map.get(c) - 1;
            map.put(c, num);

        }
        return true;

    }
}
```

## 20220510：有效的字母异位词

**题目描述**

给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。

**示例**

输入：

```
s = "anagram", t = "nagaram" 	
```

输出：

```
true
```

**思路分析**



**代码**

```java
class Solution {
    public boolean isAnagram(String s, String t) {

        int[] arr = new int[26];

        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            arr[c - 'a']++;
        }

        for (int i = 0; i < t.length(); i++) {
            char c = t.charAt(i);
            arr[c - 'a']--;
            if (arr[c - 'a'] < 0) {
                return false;
            }
        }

        for (int i = 0; i < arr.length; i++) {
            if (arr[i] != 0) {
                return false;
            }
        }


        return true;

    }
}
```

## 20220511：环形链表

**题目描述**

给你一个链表的头节点 head ，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。

如果链表中存在环 ，则返回 true 。 否则，返回 false 。

**示例**

输入：

```
head = [3,2,0,-4], pos = 1
```

输出：

```
true
```

**思路分析**



**代码**

```java
public class Solution {
    public boolean hasCycle(ListNode head) {
        ListNode fast = head;
        ListNode low = head;

        while (fast != null && fast.next != null) {
            fast = fast.next.next;
            low = low.next;
            if (low == fast) {
                return true;
            }
        }

        return false;
        
    }
}
```

## 20220511：合并两个升序链表

**题目描述**

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

**示例**

输入：

```
l1 = [1,2,4], l2 = [1,3,4]
```

输出：

```
[1,1,2,3,4,4]
```

**思路分析**



**代码**

```java
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {

        ListNode res = new ListNode(0), dum = res;
        while (list1 != null && list2 != null) {
            if (list1.val <= list2.val) {
                dum.next = list1;
                list1 = list1.next;
            } else {
                dum.next = list2;
                list2 = list2.next;
            }
            dum = dum.next;
        }
        
        dum.next = list1 == null ? list2 : list1;
        return res.next;

    }
}
```

## 20220511：移除链表元素

**题目描述**

给你一个链表的头节点 `head` 和一个整数 `val` ，请你删除链表中所有满足 `Node.val == val` 的节点，并返回 **新的头节点** 。

**示例**

输入：

```
head = [1,2,6,3,4,5,6], val = 6
```

输出：

```
[1,2,3,4,5]
```

**思路分析**

双指针

**代码**

```java
class Solution {
    public ListNode removeElements(ListNode head, int val) {

        ListNode res = new ListNode(0), dum = res;
        dum.next = head;

        while (head != null) {
            if (head.val == val) {
                ListNode next = head.next;
                dum.next = next;
                head = next;
            } else {
                dum = dum.next;
                head = head.next;
            }

        }


        return res.next;

    }
}
```

































## 20220511：

**题目描述**



**示例**

输入：

```

```

输出：

```

```

**思路分析**



**代码**

```java

```

























