## 20220505：存在重复元素

**题目描述**

给你一个整数数组 `nums` 。如果任一值在数组中出现 **至少两次** ，返回 `true` ；如果数组中每个元素互不相同，返回 `false` 。

**示例**

输入：

```
nums = [1,2,3,1]
```

输出：

```
true
```

**思路分析**

hashset

**代码**

```java
class Solution {
    public boolean containsDuplicate(int[] nums) {

        Set<Integer> set = new HashSet<>();
        for (int num : nums) {
            if (!set.add(num)){
                return true;
            }
        }

        return false;

    }
}
```

## 20220505：最大子数组和

**题目描述**

给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**子数组** 是数组中的一个连续部分。

**示例**

输入：

```
nums = [-2,1,-3,4,-1,2,1,-5,4]
```

输出：

```
6
```

**思路分析**

动态规划

**代码**

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int n = nums.length;
        int max = nums[0];
        int[] dp = new int[n];
        dp[0] = nums[0];
        for (int i = 1; i < n; i++) {
            dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]);
            max = Math.max(max, dp[i]);
        }

        return max;

    }
}
```

## 20220506：两数之和

**题目描述**

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

**示例**

输入：

```
nums = [2,7,11,15], target = 9
```

输出：

```
[0,1]
```

**思路分析**

hashmap

**代码**

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {

        Map<Integer, Integer> map = new HashMap<>();

        for (int i = 0; i < nums.length; i++) {

            int num = nums[i];
            if (map.containsKey(num)) {
                return new int[]{i, map.get(num)};
            }
            map.put(target - nums[i], i);

        }

        return new int[2];

    }
}
```

## 20220506：合并两个有序数组

**题目描述**

给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。

请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。

注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。

**示例**

输入：

```
nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
```

输出：

```
[1,2,2,3,5,6]
```

**思路分析**

思路一：直接排序

思路二：逆序双指针

**代码**

思路一：

```java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {

        for (int i = m; i < m + n; i++) {
            nums1[i] = nums2[i - m];
        }

        Arrays.sort(nums1);

    }
}
```

思路二：

```java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {

        int i = m - 1, j = n - 1;
        for (int k = m + n - 1; k >= 0; k--) {

            if (j < 0) {
                nums1[k] = nums1[i--];
            } else if (i < 0) {
                nums1[k] = nums2[j--];
            } else if (nums1[i] >= nums2[j]) {
                nums1[k] = nums1[i--];
            } else {
                nums1[k] = nums2[j--];
            }
        }

    }
}
```

## 20220507：两个数组的交集II

**题目描述**

给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。

**示例**

输入：

```
nums1 = [1,2,2,1], nums2 = [2,2]
```

输出：

```
[2,2]
```

**思路分析**

hashmap

**代码**

```java
class Solution {
    public int[] intersect(int[] nums1, int[] nums2) {

        if (nums1.length < nums2.length) {
            return intersect(nums2, nums1);
        }

        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums2.length; i++) {
            int num = nums2[i];
            int count = map.getOrDefault(num, 0) + 1;
            map.put(num, count);
        }

        int[] res = new int[nums2.length];
        int index = 0;
        for (int i = 0; i < nums1.length; i++) {
            int num = nums1[i];
            int count = map.getOrDefault(num, 0);
            if (count > 0) {
                res[index++] = num;
                count--;
                if (count > 0) {
                    map.put(num, count);
                } else {
                    map.remove(num);
                }
            }

        }



        return Arrays.copyOfRange(res, 0, index);

    }
}
```

## 20220507：买卖股票的最佳时机

**题目描述**

给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

**示例**

输入：

```
[7,1,5,3,6,4]
```

输出：

```
5
```

**思路分析**

动态规划

**代码**

```java
class Solution {
    public int maxProfit(int[] prices) {

        int cost = Integer.MAX_VALUE, max = Integer.MIN_VALUE;

        for (int i = 0; i < prices.length; i++) {

            int price = prices[i];
            cost = Math.min(cost, price);
            max = Math.max(price - cost, max);
        }


        return max;

    }
}
```

## 20220508：重塑矩阵

**题目描述**

在 MATLAB 中，有一个非常有用的函数 reshape ，它可以将一个 m x n 矩阵重塑为另一个大小不同（r x c）的新矩阵，但保留其原始数据。

给你一个由二维数组 mat 表示的 m x n 矩阵，以及两个正整数 r 和 c ，分别表示想要的重构的矩阵的行数和列数。

重构后的矩阵需要将原始矩阵的所有元素以相同的 行遍历顺序 填充。

如果具有给定参数的 reshape 操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。

**示例**

输入：

```
mat = [[1,2],[3,4]], r = 1, c = 4
```

输出：

```
[[1,2,3,4]]
```

**思路分析**

无

**代码**

```java
class Solution {
    public int[][] matrixReshape(int[][] mat, int r, int c) {

        int m = mat.length, n = mat[0].length;
        if (m * n != r * c) {
            return mat;
        }

        int[][] res = new int[r][c];

        int q = 0, p = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                res[q][p++] = mat[i][j];
                if (p == c) {
                    p = 0;
                    q++;
                }

            }
        }
        
        return res;

    }
}
```

## 20220508：杨辉三角

**题目描述**

给定一个非负整数 *`numRows`，*生成「杨辉三角」的前 *`numRows`* 行。

在「杨辉三角」中，每个数是它左上方和右上方的数的和。

**示例**

输入：

```
numRows = 5
```

输出：

```
[[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]
```

**思路分析**

无

**代码**

```java
class Solution {
    public List<List<Integer>> generate(int numRows) {

        List<List<Integer>> res = new ArrayList<>();

        res.add(new ArrayList<Integer>(){{
            add(1);
        }});

        if (numRows == 1) {
            return res;
        }

        for (int i = 1; i < numRows; i++) {
            List<Integer> curList = res.get(i - 1);
            List<Integer> nextList = new ArrayList<>();
            nextList.add(1);
            for (int j = 1; j < curList.size(); j++) {
                int num = curList.get(j) + curList.get(j - 1);
                nextList.add(num);
            }
            nextList.add(1);

            res.add(nextList);
        }

        return res;

    }
}
```

## 20220509：有效的数独

**题目描述**

请你判断一个 9 x 9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。

    数字 1-9 在每一行只能出现一次。
    数字 1-9 在每一列只能出现一次。
    数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）

 注意：

    一个有效的数独（部分已被填充）不一定是可解的。
    只需要根据以上规则，验证已经填入的数字是否有效即可。
    空白格用 '.' 表示。

**示例**

输入：

```
board = 
[["8","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
```

输出：

```
false
```

**思路分析**

分别使用rows数组，cols数组和subboxes数组存储。

**代码**

```java
class Solution {
    public boolean isValidSudoku(char[][] board) {

        int[][] rows = new int[9][9];
        int[][] cols = new int[9][9];
        int[][][] subboxes = new int[3][3][9];

        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {

                char c = board[i][j];
                if (c != '.') {
                    int index = c - '0' - 1;
                    rows[i][index]++;
                    cols[j][index]++;
                    subboxes[i / 3][j / 3][index]++;
                    if (rows[i][index] > 1 || cols[j][index] > 1 || subboxes[i / 3][j / 3][index] > 1) {
                        return false;
                    }

                }

            }
        }


        return true;

    }
}
```

## 20220509：矩阵置0

**题目描述**

给定一个 `*m* x *n*` 的矩阵，如果一个元素为 **0** ，则将其所在行和列的所有元素都设为 **0** 。请使用 **[原地](http://baike.baidu.com/item/原地算法)** 算法**。**

**示例**

输入：

```
matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]
```

输出：

```
[[0,0,0,0],[0,4,5,0],[0,3,1,0]]
```

**思路分析**

无

**代码**

```java
class Solution {
    public void setZeroes(int[][] matrix) {

        int m = matrix.length, n = matrix[0].length;
        Queue<int[]> queue = new LinkedList<>();
        boolean[][] judge = new boolean[m][n];

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (matrix[i][j] == 0) {
                    queue.offer(new int[]{i , j});
                    judge[i][j] = true;
                }
            }
        }

        while (!queue.isEmpty()) {
            int[] x = queue.poll();
            for (int i = 0; i < m; i++) {
                for (int j = 0; j < n; j++) {
                    if ((i == x[0] || j == x[1]) && !judge[i][j]) {
                        matrix[i][j] = 0;
                        judge[i][j] = true;
                    }
                }
            }
        }

    }
}
```

## 20220510：字符串中的第一个唯一字符

**题目描述**

给定一个字符串 `s` ，找到 *它的第一个不重复的字符，并返回它的索引* 。如果不存在，则返回 `-1` 。

**示例**

输入：

```
s = "leetcode"
```

输出：

```
0
```

**思路分析**

hashmap存储

**代码**

```java
class Solution {
    public int firstUniqChar(String s) {

        Map<Character, Integer> map = new HashMap<>();

        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            int num = map.getOrDefault(c, 0) + 1;
            map.put(c, num);
        }

        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (map.get(c) == 1) {
                return i;
            }

        }
        
        return -1;

    }
}
```

## 20220510：赎金信

**题目描述**

给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。

如果可以，返回 true ；否则返回 false 。

magazine 中的每个字符只能在 ransomNote 中使用一次。

**示例**

输入：

```
ransomNote = "a", magazine = "b"
```

输出：

```
false
```

**思路分析**

hashmap

**代码**

```java
class Solution {
    public boolean canConstruct(String ransomNote, String magazine) {

        Map<Character, Integer> map = new HashMap<>();

        for (int i = 0; i < magazine.length(); i++) {

            char c = magazine.charAt(i);
            int num = map.getOrDefault(c, 0) + 1;
            map.put(c, num);

        }

        for (int i = 0; i < ransomNote.length(); i++) {

            char c = ransomNote.charAt(i);
            if (!map.containsKey(c) || map.get(c) < 1) {
                return false;
            }
            int num = map.get(c) - 1;
            map.put(c, num);

        }
        return true;

    }
}
```

## 20220510：有效的字母异位词

**题目描述**

给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。

**示例**

输入：

```
s = "anagram", t = "nagaram" 	
```

输出：

```
true
```

**思路分析**



**代码**

```java
class Solution {
    public boolean isAnagram(String s, String t) {

        int[] arr = new int[26];

        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            arr[c - 'a']++;
        }

        for (int i = 0; i < t.length(); i++) {
            char c = t.charAt(i);
            arr[c - 'a']--;
            if (arr[c - 'a'] < 0) {
                return false;
            }
        }

        for (int i = 0; i < arr.length; i++) {
            if (arr[i] != 0) {
                return false;
            }
        }


        return true;

    }
}
```

## 20220511：环形链表

**题目描述**

给你一个链表的头节点 head ，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。

如果链表中存在环 ，则返回 true 。 否则，返回 false 。

**示例**

输入：

```
head = [3,2,0,-4], pos = 1
```

输出：

```
true
```

**思路分析**



**代码**

```java
public class Solution {
    public boolean hasCycle(ListNode head) {
        ListNode fast = head;
        ListNode low = head;

        while (fast != null && fast.next != null) {
            fast = fast.next.next;
            low = low.next;
            if (low == fast) {
                return true;
            }
        }

        return false;
        
    }
}
```

## 20220511：合并两个升序链表

**题目描述**

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

**示例**

输入：

```
l1 = [1,2,4], l2 = [1,3,4]
```

输出：

```
[1,1,2,3,4,4]
```

**思路分析**



**代码**

```java
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {

        ListNode res = new ListNode(0), dum = res;
        while (list1 != null && list2 != null) {
            if (list1.val <= list2.val) {
                dum.next = list1;
                list1 = list1.next;
            } else {
                dum.next = list2;
                list2 = list2.next;
            }
            dum = dum.next;
        }
        
        dum.next = list1 == null ? list2 : list1;
        return res.next;

    }
}
```

## 20220511：移除链表元素

**题目描述**

给你一个链表的头节点 `head` 和一个整数 `val` ，请你删除链表中所有满足 `Node.val == val` 的节点，并返回 **新的头节点** 。

**示例**

输入：

```
head = [1,2,6,3,4,5,6], val = 6
```

输出：

```
[1,2,3,4,5]
```

**思路分析**

双指针

**代码**

```java
class Solution {
    public ListNode removeElements(ListNode head, int val) {

        ListNode res = new ListNode(0), dum = res;
        dum.next = head;

        while (head != null) {
            if (head.val == val) {
                ListNode next = head.next;
                dum.next = next;
                head = next;
            } else {
                dum = dum.next;
                head = head.next;
            }

        }


        return res.next;

    }
}
```

## 20220512：反转链表

**题目描述**

给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

**示例**

输入：

```
head = [1,2,3,4,5]
```

输出：

```
[5,4,3,2,1]
```

**思路分析**



**代码**

```java
class Solution {
    public ListNode reverseList(ListNode head) {

        ListNode pre = null;
        ListNode cur = head;

        while (cur != null) {
            ListNode next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }

        return pre;

    }
}
```

## 20220512：删除排序链表中重复的元素

**题目描述**

给定一个已排序的链表的头 `head` ， *删除所有重复的元素，使每个元素只出现一次* 。返回 *已排序的链表* 。

**示例**

输入：

```
head = [1,1,2,3,3]
```

输出：

```
[1,2,3]
```

**思路分析**



**代码**

```java
class Solution {
    public ListNode deleteDuplicates(ListNode head) {

        if (head == null || head.next == null) {
            return head;
        }

        ListNode low = head;
        ListNode fast = head.next;
        int value = head.val;

        while (fast != null) {
            if (fast.val == value) {
                low.next = fast.next;
                fast = fast.next;
            } else {
                low = fast;
                fast = fast.next;
                value = low.val;
            }
        }

        return head;

    }
}
```

## 20220513：有效的括号

**题目描述**

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

有效字符串需满足：

    左括号必须用相同类型的右括号闭合。
    左括号必须以正确的顺序闭合。

**示例**

输入：

```
s = "()[]{}"
```

输出：

```
true
```

**思路分析**

用栈模拟

**代码**

```java
class Solution {
    public boolean isValid(String s) {

        int n = s.length();
        if (n % 2 == 1) {
            return false;
        }

        Map<Character, Character> map = new HashMap(){{
            put(')','(');
            put(']','[');
            put('}','{');
        }};


        Stack<Character> stack = new Stack<>();

        for (int i = 0; i < n; i++) {
            char c = s.charAt(i);
            if (map.containsKey(c)) {
                if (stack.isEmpty() || stack.peek() != map.get(c)){
                    return false;
                }
                stack.pop();
            } else {
                stack.push(c);
            }
            
        }

        return stack.isEmpty();

    }
}
```

## 20220513：用栈模拟队列

**题目描述**

请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：

实现 MyQueue 类：

    void push(int x) 将元素 x 推到队列的末尾
    int pop() 从队列的开头移除并返回元素
    int peek() 返回队列开头的元素
    boolean empty() 如果队列为空，返回 true ；否则，返回 false

说明：

    你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。
    你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。

**示例**

输入：

```
["MyQueue", "push", "push", "peek", "pop", "empty"]
[[], [1], [2], [], [], []]
```

输出：

```
[null, null, null, 1, 1, false]
```

**思路分析**



**代码**

```java
class MyQueue {

    Stack<Integer> stack1;
    Stack<Integer> stack2;

    public MyQueue() {
        stack1 = new Stack<>();
        stack2 = new Stack<>();
    }

    public void push(int x) {
        stack1.push(x);

    }

    public int pop() {
        adjust();

        return stack2.pop();

    }

    public int peek() {
        adjust();
        return stack2.peek();
    }

    public void adjust() {
        //当前队列为空，无需调整
        if (stack1.isEmpty() && stack2.isEmpty()) {
            return;
        }
        //当前出队栈无元素，调整入队栈。
        if (stack2.isEmpty()) {
            while (!stack1.isEmpty()) {
                stack2.push(stack1.pop());
            }
        }
    }

    public boolean empty() {
        return stack1.isEmpty() && stack2.isEmpty();
    }
}
```

## 20220514：二叉树前序遍历

**题目描述**

给你二叉树的根节点 `root` ，返回它节点值的 **前序** 遍历。

**示例**

输入：

```
root = [1,null,2,3]
```

输出：

```
[1,2,3]
```

**思路分析**



**代码**

```java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {

        List<Integer> res = new ArrayList<>();
        Stack<TreeNode> stack = new Stack<>();
        TreeNode node = root;

        while (node != null || !stack.isEmpty()) {
            if (node != null) {
                res.add(node.val);
                stack.push(node);
                node = node.left;
            } else {
                TreeNode tmp = stack.pop();
                node = tmp.right;
            }

        }

        return res;
    }
}
```

## 20220514：二叉树中序遍历

**题目描述**

给你二叉树的根节点 `root` ，返回它节点值的 **中序** 遍历。

**示例**

输入：

```
root = [1,null,2,3]
```

输出：

```
[1,3,2]
```

**思路分析**



**代码**

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {

        List<Integer> res = new ArrayList<>();
        Stack<TreeNode> stack = new Stack<>();
        TreeNode node = root;

        while (node != null || !stack.isEmpty()) {
            if (node != null) {

                stack.push(node);
                node = node.left;
            } else {
                TreeNode tmp = stack.pop();
                res.add(tmp.val);
                node = tmp.right;
            }

        }

        return res;

    }
}
```

## 20220514：二叉树后序遍历

**题目描述**

给你二叉树的根节点 `root` ，返回它节点值的 **后序** 遍历。

**示例**

输入：

```
root = [1,null,2,3]
```

输出：

```
[3,2,1]
```

**思路分析**



**代码**

```java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        
        if (root == null) {
            return res;
        }
        
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        TreeNode cur, pre= null;

        while (!stack.isEmpty()) {
            cur = stack.peek();
            if ((cur.left == null && cur.right == null) || pre != null && (cur.left == pre || cur.right == pre)) {
                res.add(cur.val);
                stack.pop();
                pre = cur;
            } else {
                if (cur.right != null) {
                    stack.push(cur.right);
                }
                if (cur.left != null) {
                    stack.push(cur.left);
                }
            }

        }
        return res;

    }
}
```

## 20220515：二叉树的层序遍历

**题目描述**

给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。

**示例**

输入：

```
root = [3,9,20,null,null,15,7]
```

输出：

```
[[3],[9,20],[15,7]]
```

**思路分析**



**代码**

```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {

        List<List<Integer>> res = new ArrayList<>();
        if (root == null) {
            return res;
        }

        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        
        while (!queue.isEmpty()) {
            
            int len = queue.size();
            List<Integer> list = new ArrayList<>();
            for (int i = 0; i < len; i++) {
                TreeNode node = queue.poll();
                list.add(node.val);
                if (node.left != null) {
                    queue.offer(node.left);
                }
                if (node.right != null) {
                    queue.offer(node.right);
                }
            }
            res.add(list);
            
        }

        return res;

    }
}
```

## 20220515：二叉树的最大深度

**题目描述**

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

**说明:** 叶子节点是指没有子节点的节点。

**示例**

输入：

```
    3
   / \
  9  20
    /  \
   15   7
```

输出：

```
3
```

**思路分析**



**代码**

```java
class Solution {
    public int maxDepth(TreeNode root) {

        if (root == null) {
            return 0;
        }
        
        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1; 

    }
}
```

## 20220515：对称二叉树

**题目描述**

给你一个二叉树的根节点 `root` ， 检查它是否轴对称。

**示例**

输入：

```
root = [1,2,2,3,4,4,3]
```

输出：

```
true
```

**思路分析**



**代码**

```java
class Solution {
    public boolean isSymmetric(TreeNode root) {

        return check(root.left, root.right);

    }

    public static boolean check(TreeNode left, TreeNode right) {

        if (left == null && right == null) {
            return true;
        }

        if (left == null || right == null) {
            return false;
        }
        return left.val == right.val && check(left.right, right.left) && check(left.left, right.right);
    }

}
```

## 20220516：翻转二叉树

**题目描述**

给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。

**示例**

输入：

```
root = [4,2,7,1,3,6,9]
```

输出：

```
[4,7,2,9,6,3,1]
```

**思路分析**



**代码**

```java
class Solution {
    public TreeNode invertTree(TreeNode root) {

        if (root == null) {
            return null;
        }

        TreeNode left = invertTree(root.left);
        TreeNode right = invertTree(root.right);
        
        root.left = right;
        root.right = left;
        return root;

    }
}
```

## 20220516：路径总和

**题目描述**

给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。

叶子节点 是指没有子节点的节点。

**示例**

输入：

```
root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
```

输出：

```
true
```

**思路分析**

DFS

**代码**

```java
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {

        if (root == null) {
            return false;
        }

        if (root.left == null && root.right == null) {
            return root.val == targetSum;
        }

        return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);


    }
}
```

## 20220517：二叉搜索树中的搜索

**题目描述**

给定二叉搜索树（BST）的根节点 root 和一个整数值 val。

你需要在 BST 中找到节点值等于 val 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 null 。

**示例**

输入：

```
root = [4,2,7,1,3], val = 2
```

输出：

```
[2,1,3]
```

**思路分析**



**代码**

```java
class Solution {
    public TreeNode searchBST(TreeNode root, int val) {

        while (root != null) {
            if (root.val == val) {
                return root;
            } else if (root.val < val) {
                root = root.right;
            } else {
                root = root.left;
            }
        }
        return null;

    }
}
```

## 20220517：二叉搜索树中的插入操作

**题目描述**

给定二叉搜索树（BST）的根节点 root 和要插入树中的值 value ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。

注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/insert-into-a-binary-search-tree
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

**示例**

输入：

```
root = [4,2,7,1,3], val = 5
```

输出：

```
[4,2,7,1,3,5]
```

**思路分析**

遍历找到插入位置，记录下前一个结点，赋值。

**代码**

```java
class Solution {
    public TreeNode insertIntoBST(TreeNode root, int val) {

        if (root == null) {
            root = new TreeNode(val);
            return root;
        }

        TreeNode node = root;
        TreeNode pre = null;

        while (node != null) {
            pre = node;
            if (node.val > val) {
                node = node.left;
            } else {
                node = node.right;
            }
        }

        if (pre.val > val) {
            pre.left = new TreeNode(val);
        } else {
            pre.right = new TreeNode(val);
        }

        return root;

    }
}
```

## 20220518：二叉搜索树的最近公共祖先

**题目描述**

给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]

**示例**

输入：

```
root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
```

输出：

```
6
```

**思路分析**

递归

**代码**

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (p.val > root.val && q.val > root.val) {
            return lowestCommonAncestor(root.right, p, q);
        } else if (p.val < root.val && q.val < root.val) {
            return lowestCommonAncestor(root.left, p, q);
        } else {
            return root;
        }
    }
}
```

## 20220518：验证二叉搜索树

**题目描述**

给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。

有效 二叉搜索树定义如下：

- 节点的左子树只包含 小于 当前节点的数。
- 节点的右子树只包含 大于 当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。

**示例**

输入：

```
root = [2,1,3]
```

输出：

```
true
```

**思路分析**

二叉搜索树的中序遍历就是按顺序的，如果不按顺序，就不是二叉搜索树

**代码**

```java
class Solution {
    public boolean isValidBST(TreeNode root) {

        Stack<TreeNode> stack = new Stack<>();
        TreeNode node = root;
        long pre = Long.MIN_VALUE;

        while (node != null || !stack.isEmpty()) {
            if (node != null) {
                stack.push(node);

                node = node.left;
            } else {
                TreeNode tmp = stack.pop();
                if (pre >= tmp.val) {
                    return false;
                }
                pre = tmp.val;
                node = tmp.right;
            }
        }
        return true;


    }
}
```

## 20220518：两数之和IV-输入BSF

**题目描述**

给定一个二叉搜索树 `root` 和一个目标结果 `k`，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 `true`。

**示例**

输入：

```
root = [5,3,6,2,4,null,7], k = 9
```

输出：

```
true
```

**思路分析**

中序遍历+list存储

**代码**

```java
class Solution {
    public boolean findTarget(TreeNode root, int k) {

        Stack<TreeNode> stack = new Stack<>();
        TreeNode node = root;
        List<Integer> list = new ArrayList<>();

        while (node != null || !stack.isEmpty()) {
            if (node != null) {
                stack.push(node);
                if (list.contains(node.val)) {
                    return true;
                }
                list.add(k - node.val);
                node = node.left;
            } else {
                TreeNode tmp = stack.pop();

                node = tmp.right;
            }
        }
        return false;

    }
}
```

## 20220518：只出现一次的数字

**题目描述**

给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

说明：

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

**示例**

输入：

```
[4,1,2,1,2]
```

输出：

```
4
```

**思路分析**



**代码**

```java
class Solution {
    public int singleNumber(int[] nums) {

        int res = 0;
        for (int i = 0; i < nums.length; i++) {
            res ^= nums[i];
        }
        
        return res;

    }
}
```

## 20220518：多数元素

**题目描述**

给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

**示例**

输入：

```
nums = [2,2,1,1,1,2,2]
```

输出：

```
2
```

**思路分析**

摩尔投票

**代码**

```java
class Solution {
    public int majorityElement(int[] nums) {

        int res = nums[0];
        int count = 1;
        for (int i = 1; i < nums.length; i++) {
            count = nums[i] == res ? count + 1 : count - 1;
            if (count == 0) {
                res = nums[i];
                count = 1;
            }

        }

        return res;

    }
}
```

## 20220518：三数之和

**题目描述**

给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。

注意：答案中不可以包含重复的三元组。

**示例**

输入：

```
nums = [-1,0,1,2,-1,-4]
```

输出：

```
[[-1,-1,2],[-1,0,1]]
```

**思路分析**

循环+双指针+剪枝。

**代码**

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {

        List<List<Integer>> res = new ArrayList<>();
        if (nums.length < 3) {
            return res;
        }

        Arrays.sort(nums);

        //第一层循环
        for (int k = 0; k < nums.length - 2; k++) {
            int i = k + 1, j = nums.length - 1;
            if (k > 0 && nums[k] == nums[k - 1]) {
                continue;
            }
            if (nums[k] + nums[k + 1] + nums[k + 2] > 0) {
                continue;
            }
            if (nums[k] + nums[j - 1] + nums[j] < 0) {
                continue;
            }
            while (i < j) {
                int sum = nums[k] + nums[i] + nums[j];
                if (sum < 0) {
                    while (i < j && nums[i] == nums[++i]);
                } else if (sum > 0) {
                    while (i < j && nums[j] == nums[--j]);
                } else {
                    res.add(Arrays.asList(nums[k], nums[i], nums[j]));
                    while (i < j && nums[i] == nums[++i]);
                    while (i < j && nums[j] == nums[--j]);
                }
            }
        }

        return res;

    }
}
```

## 20220519：颜色分类

**题目描述**

给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。

必须在不使用库的sort函数的情况下解决这个问题。

**示例**

输入：

```
nums = [2,0,2,1,1,0]
```

输出：

```
[0,0,1,1,2,2]
```

**思路分析**

用O(n)的复杂度遍历即可

**代码**

```java
class Solution {
    public void sortColors(int[] nums) {

        int pos = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] == 0) {
                int tmp = nums[i];
                nums[i] = nums[pos];
                nums[pos] = tmp;
                pos++;
            }
        }

        for (int i = pos; i < nums.length; i++) {
            if (nums[i] == 1) {
                int tmp = nums[i];
                nums[i] = nums[pos];
                nums[pos] = tmp;
                pos++;
            }
        }

    }
}
```

## 20220519：合并区间

**题目描述**

以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。

**示例**

输入：

```
intervals = [[1,3],[2,6],[8,10],[15,18]]
```

输出：

```
[[1,6],[8,10],[15,18]]
```

**思路分析**

排序之后进行遍历比较。当`intervals[i][1] <= intervals[i + 1][1]`时，继续比较`intervals[i][1] >= intervals[i + 1][0]`，

**代码**

```java
class Solution {
    public int[][] merge(int[][] intervals) {

        Arrays.sort(intervals, new Comparator<int[]>() {
            @Override
            public int compare(int[] o1, int[] o2) {
                return o1[0] - o2[0];
            }
        });
        int len = intervals.length;

        for (int i = 0; i < intervals.length - 1; i++) {
            //前一个的后边界比后一个的后边界小
            if (intervals[i][1] <= intervals[i + 1][1]) {
                //前一个的后边界大于等于后一个的前边界
                if (intervals[i][1] >= intervals[i + 1][0]) {
                    intervals[i + 1] = new int[]{intervals[i][0], intervals[i + 1][1]};
                    intervals[i] = null;
                    len--;
                }
                //前一个的后边界小于后一个的前边界,保留
            } else { //前一个的后边界比后一个的后边界大，让后一个等于前一个
                intervals[i + 1] = intervals[i];
                intervals[i] = null;
                len--;
            }

        }

        int[][] res = new int[len][2];
        int index = 0;
        for (int i = 0; i < intervals.length; i++) {
            if (intervals[i] != null) {
                res[index++] = intervals[i];
            }
        }

        return res;
    }
}
```

## 20220519：设计哈希映射

**题目描述**

不使用任何内建的哈希表库设计一个哈希映射（HashMap）。

实现 MyHashMap 类：

- MyHashMap() 用空映射初始化对象
- void put(int key, int value) 向 HashMap 插入一个键值对 (key, value) 。如果 key 已经存在于映射中，则更新其对应的值 value 。
- int get(int key) 返回特定的 key 所映射的 value ；如果映射中不包含 key 的映射，返回 -1 。
- void remove(key) 如果映射中存在 key 的映射，则移除 key 和它所对应的 value 。

**示例**

输入：

```
["MyHashMap", "put", "put", "get", "get", "put", "get", "remove", "get"]
[[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]]
```

输出：

```
[null, null, null, 1, -1, null, 1, null, -1]
```

**思路分析**



**代码**

```java
class MyHashMap {
    Node head;

    public MyHashMap() {
    }

    public void put(int key, int value) {
        if (head == null) {
            head = new Node(key, value);
        } else {
            Node node = head;
            boolean judge = false;
            while (node != null) {
                if (node.key == key) {
                    node.value = value;
                    judge = true;
                }
                node = node.next;
            }

            if (!judge) {
                Node newNode = new Node(key, value);
                newNode.next = head;
                head = newNode;
            }

        }
    }

    public int get(int key) {

        Node node = head;
        while (node != null) {
            if (node.key == key) {
                return node.value;
            }
            node = node.next;
        }
        return -1;
    }

    public void remove(int key) {
        if (head == null) {
            return;
        }
        
        if (head.next == null) {
            if (head.key == key) {
                head = null;
            }
            return;
        }

        if (head.key == key) {
            head = head.next;
            return;
        }

        Node cur = head.next;
        Node pre = head;

        while (cur != null) {
            if (cur.key == key) {
                pre.next = cur.next;
            }
            pre = pre.next;
            cur = cur.next;
        }


    }

    static class Node {

        int key;
        int value;
        Node next;
        Node(){}

        Node(int key, int value){
            this.key = key;
            this.value = value;
        }

    }
}
```

## 20220520：杨辉三角II

**题目描述**

给定一个非负索引 `rowIndex`，返回「杨辉三角」的第 `rowIndex` 行。

在「杨辉三角」中，每个数是它左上方和右上方的数的和。

**示例**

输入：

```
rowIndex = 3
```

输出：

```
[1,3,3,1]
```

**思路分析**



**代码**

```java
class Solution {
    public List<Integer> getRow(int rowIndex) {

        if (rowIndex == 0) {
            return new ArrayList<Integer>(){{
                add(1);
            }};
        }

        List<Integer> res = new ArrayList(){{
            add(1);
            add(1);
        }};

        for (int i = 1; i < rowIndex; i++) {

            List<Integer> tmp = new ArrayList<>();
            tmp.add(1);
            for (int j = 1; j < i + 1; j++) {
                tmp.add(res.get(j - 1) + res.get(j));
            }
            tmp.add(1);
            res = tmp;
        }


        return res;

    }
}
```

## 20220520：旋转矩阵

**题目描述**

给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。

你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。

**示例**

输入：

```
matrix = [[1,2,3],[4,5,6],[7,8,9]]
```

输出：

```
[[7,4,1],[8,5,2],[9,6,3]]
```

**思路分析**



**代码**

```java
class Solution {
    public void rotate(int[][] matrix) {

        int m = matrix.length;

        //反转
        for (int k = 0; k < m; k++) {
            int i = 0, j = m - 1;
            while (i <= j) {
                int tmp = matrix[k][i];
                matrix[k][i] = matrix[k][j];
                matrix[k][j] = tmp;
                i++;
                j--;
            }
        }

        //旋转
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < m - i - 1; j++) {
                int tmp = matrix[i][j];
                matrix[i][j] = matrix[m - 1 - j][m - 1 - i];
                matrix[m - 1 - j][m - 1 - i] = tmp;
            }
        }

    }
}
```

## 20220520：螺旋矩阵II

**题目描述**

给你一个正整数 `n` ，生成一个包含 `1` 到 `n2` 所有元素，且元素按顺时针顺序螺旋排列的 `n x n` 正方形矩阵 `matrix` 。

**示例**

输入：

```
n = 3
```

输出：

```
[[1,2,3],[8,9,4],[7,6,5]]
```

**思路分析**



**代码**

```java
class Solution {
    public int[][] generateMatrix(int n) {

        int[][] res = new int[n][n];

        int up = 0, low = n - 1, left = 0, right = n - 1;
        int i =1;
        while (i <= n * n) {

            for (int j = left; j <= right; j++) {
                res[up][j] = i++;
            }
            up++;
            for (int j = up; j <= low; j++) {
                res[j][right] = i++;
            }
            right--;
            for (int j = right; j >= left; j--) {
                res[low][j] = i++;
            }
            low--;
            for (int j = low; j >= up; j--) {
                res[j][left] = i++;
            }
            left++;
        }

        return res;

    }
}
```

## 20220521：搜索二维矩阵II

**题目描述**

编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：

- 每行的元素从左到右升序排列。
- 每列的元素从上到下升序排列。

**示例**

输入：

```
matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5
```

输出：

```
true
```

**思路分析**



**代码**

```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {

        int m = matrix.length, n = matrix[0].length;
        int i = 0, j = n - 1;

        while (i <= m - 1 && j >= 0) {
            if (matrix[i][j] < target) {
                i++;
            } else if (matrix[i][j] > target) {
                j--;
            } else {
                return true;
            }
        }

        return false;
        
    }
}
```

## 20220521：无重叠区间

**题目描述**

给定一个区间的集合 intervals ，其中 intervals[i] = [starti, endi] 。返回 需要移除区间的最小数量，使剩余区间互不重叠 。

**示例**

输入：

```
intervals = [[1,2],[2,3],[3,4],[1,3]]
```

输出：

```
1
```

**思路分析**

https://leetcode.cn/problems/non-overlapping-intervals/solution/wu-zhong-die-qu-jian-by-leetcode-solutio-cpsb/

**代码**

```java
class Solution {
    public int eraseOverlapIntervals(int[][] intervals) {

        if (intervals.length == 0) {
            return 0;
        }

        Arrays.sort(intervals, new Comparator<int[]>() {
            @Override
            public int compare(int[] o1, int[] o2) {
                return o1[1] - o2[1];
            }
        });


        int n = intervals.length;
        int right = intervals[0][1];
        int ans = 1;
        for (int i = 1; i < n; ++i) {
            if (intervals[i][0] >= right) {
                ++ans;
                right = intervals[i][1];
            }
        }
        return n - ans;

    }
}
```

## 20220522：递增的三元子序列

**题目描述**

给你一个整数数组 nums ，判断这个数组中是否存在长度为 3 的递增子序列。

如果存在这样的三元组下标 (i, j, k) 且满足 i < j < k ，使得 nums[i] < nums[j] < nums[k] ，返回 true ；否则，返回 false 。

**示例**

输入：

```
nums = [1,2,3,4,5]
```

输出：

```
true
```

**思路分析**

建立两个数组，左边最小和右边最大数组，如果存在nums[i]，使得left[i-1]<nums[i]<right[i+1]，则返回true

**代码**

```java
class Solution {
    public boolean increasingTriplet(int[] nums) {

        int n = nums.length;

        if (n <= 2) {
            return false;
        }

        int[] left = new int[n];
        left[0] = nums[0];
        int[] right = new int[n];
        right[n - 1] = nums[n - 1];
        for (int i = 1; i < n; i++) {
            left[i] = Math.min(left[i - 1], nums[i]);
        }

        for (int i = n - 2; i >= 0; i--) {
            right[i] = Math.max(right[i + 1], nums[i]);
        }

        for (int i = 1; i < n - 1; i++) {
            if (nums[i] > left[i - 1] && nums[i] < right[i + 1]) {
                return true;
            }
        }
        return false;

    }
}
```

## 20220522：除自身以外的乘积

**题目描述**

给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。

题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在  32 位 整数范围内。

请不要使用除法，且在 O(n) 时间复杂度内完成此题。

**示例**

输入：

```
nums = [1,2,3,4]
```

输出：

```
[24,12,8,6]
```

**思路分析**



**代码**

```java
class Solution {
    public int[] productExceptSelf(int[] nums) {

        int n = nums.length;
        int[] res = new int[n];
        for (int i = 0; i < n; i++) {
            res[i] = 1;
        }
        int num = 1;
        for (int i = 0; i < n - 1; i++) {
            num *= nums[i];
            res[i + 1] *= num;
        }

        num = 1;
        for (int i = n - 1; i > 0; i--) {
            num *= nums[i];
            res[i - 1] *= num;
        }
        
        return res;

    }
}
```

## 20220522：和为K的子数组

**题目描述**

给你一个整数数组 `nums` 和一个整数 `k` ，请你统计并返回 *该数组中和为 `k` 的子数组的个数* 。

**示例**

输入：

```
nums = [1,1,1], k = 2
```

输出：

```
2
```

**思路分析**

遍历即可。

**代码**

```java
class Solution {
    public int subarraySum(int[] nums, int k) {

        int count = 0;
        for (int i = 0; i < nums.length; i++) {
            int sum = 0;
            for (int end = i; end >= 0; --end) {
                sum += nums[end];
                if (sum == k) {
                    count++;
                }
            }
        }
        
        return count;

    }
}
```

## 20220523：最长回文串

**题目描述**

给定一个包含大写字母和小写字母的字符串 s ，返回 通过这些字母构造成的 最长的回文串 。

在构造过程中，请注意 区分大小写 。比如 "Aa" 不能当做一个回文字符串。

**示例**

输入：

```
s = "abccccdd"
```

输出：

```
7
```

**思路分析**

hashmap

**代码**

```java
class Solution {
    public int longestPalindrome(String s) {

        Map<Character, Integer> map = new HashMap<>();
        for (int i = 0; i < s.length(); i++) {
            int num = map.getOrDefault(s.charAt(i), 0) + 1;
            map.put(s.charAt(i), num);
        }

        int res = 0;
        int single = 0;
        for (Character c : map.keySet()) {
            int num = map.get(c);
            if (num % 2 == 1) {
                single++;
            }
            res += (num / 2) * 2;
        }
        if (single != 0){
            res++;
        }

        return res;

    }
}
```

## 20220523：字符串相加

**题目描述**

给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和并同样以字符串形式返回。

你不能使用任何內建的用于处理大整数的库（比如 BigInteger）， 也不能直接将输入的字符串转换为整数形式。

**示例**

输入：

```
num1 = "11", num2 = "123"
```

输出：

```
"134"
```

**思路分析**



**代码**

```java
class Solution {
    public String addStrings(String num1, String num2) {

        int i = num1.length() - 1, j = num2.length() - 1, add = 0;
        StringBuilder res = new StringBuilder();

        while (i >= 0 || j >= 0 || add != 0) {
            int x = i >= 0 ? num1.charAt(i) - '0' : 0;
            int y = j >= 0 ? num2.charAt(j) - '0' : 0;
            int num = x + y + add;
            res.append(num % 10);
            add = num >= 10 ? 1 : 0;
            i--;
            j--;

        }

        return res.reverse().toString();

    }
}
```

## 20220524：单词规律

**题目描述**

给定一种规律 pattern 和一个字符串 s ，判断 s 是否遵循相同的规律。

这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应规律。

**示例**

输入：

```
pattern = "abba", str = "dog cat cat dog"
```

输出：

```
true
```

**思路分析**

用hashmap存储对应关系。

**代码**

```java
class Solution {
    public boolean wordPattern(String pattern, String s) {

        String[] c = s.split(" ");
        if (c.length != pattern.length()) {
            return false;
        }

        char[] p = pattern.toCharArray();
        Map<Character, String> map = new HashMap<>();

        for (int i = 0; i < c.length; i++) {
            if (map.containsKey(p[i]) || map.containsValue(c[i])) {
                if (!map.containsKey(p[i]) || !map.get(p[i]).equals(c[i])) {
                    return false;
                }
            } else {
                map.put(p[i], c[i]);
            }
        }
        return true;   

    }
}
```

## 20220524：划分字母区间

**题目描述**

字符串 `S` 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。

**示例**

输入：

```
S = "ababcbacadefegdehijhklij"
```

输出：

```
[9,7,8]
```

**思路分析**

贪心。https://leetcode.cn/problems/partition-labels/solution/hua-fen-zi-mu-qu-jian-by-leetcode-solution/

**代码**

```java
class Solution {
    public List<Integer> partitionLabels(String s) {

        //得到每个字母最后出现的位置列表
        int[] words = new int[26];
        for (int i = 0; i < s.length(); i++) {
            words[s.charAt(i) - 'a'] = i;
        }

        List<Integer> res = new ArrayList<>();
        int start = 0, end = 0;
        for (int i = 0; i < s.length(); i++) {
            end = Math.max(end, words[s.charAt(i) - 'a']);
            if (end == i) {
                res.add(end - start + 1);
                start = end + 1;
            }
        }
        return res;

    }
}
```































## 20220524：

**题目描述**



**示例**

输入：

```

```

输出：

```

```

**思路分析**



**代码**

```java

```

























