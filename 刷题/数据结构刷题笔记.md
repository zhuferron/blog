## 20220505：存在重复元素

**题目描述**

给你一个整数数组 `nums` 。如果任一值在数组中出现 **至少两次** ，返回 `true` ；如果数组中每个元素互不相同，返回 `false` 。

**示例**

输入：

```
nums = [1,2,3,1]
```

输出：

```
true
```

**思路分析**

hashset

**代码**

```java
class Solution {
    public boolean containsDuplicate(int[] nums) {

        Set<Integer> set = new HashSet<>();
        for (int num : nums) {
            if (!set.add(num)){
                return true;
            }
        }

        return false;

    }
}
```

## 20220505：最大子数组和

**题目描述**

给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**子数组** 是数组中的一个连续部分。

**示例**

输入：

```
nums = [-2,1,-3,4,-1,2,1,-5,4]
```

输出：

```
6
```

**思路分析**

动态规划

**代码**

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int n = nums.length;
        int max = nums[0];
        int[] dp = new int[n];
        dp[0] = nums[0];
        for (int i = 1; i < n; i++) {
            dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]);
            max = Math.max(max, dp[i]);
        }

        return max;

    }
}
```

## 20220506：两数之和

**题目描述**

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

**示例**

输入：

```
nums = [2,7,11,15], target = 9
```

输出：

```
[0,1]
```

**思路分析**

hashmap

**代码**

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {

        Map<Integer, Integer> map = new HashMap<>();

        for (int i = 0; i < nums.length; i++) {

            int num = nums[i];
            if (map.containsKey(num)) {
                return new int[]{i, map.get(num)};
            }
            map.put(target - nums[i], i);

        }

        return new int[2];

    }
}
```

## 20220506：合并两个有序数组

**题目描述**

给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。

请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。

注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。

**示例**

输入：

```
nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
```

输出：

```
[1,2,2,3,5,6]
```

**思路分析**

思路一：直接排序

思路二：逆序双指针

**代码**

思路一：

```java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {

        for (int i = m; i < m + n; i++) {
            nums1[i] = nums2[i - m];
        }

        Arrays.sort(nums1);

    }
}
```

思路二：

```java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {

        int i = m - 1, j = n - 1;
        for (int k = m + n - 1; k >= 0; k--) {

            if (j < 0) {
                nums1[k] = nums1[i--];
            } else if (i < 0) {
                nums1[k] = nums2[j--];
            } else if (nums1[i] >= nums2[j]) {
                nums1[k] = nums1[i--];
            } else {
                nums1[k] = nums2[j--];
            }
        }

    }
}
```

































## 20220506：

**题目描述**



**示例**

输入：

```

```

输出：

```

```

**思路分析**



**代码**

```java

```

























