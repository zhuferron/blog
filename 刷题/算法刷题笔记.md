## 20220421：二分查找

**题目描述**

给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

**示例**

输入：

```
nums = [-1,0,3,5,9,12], target = 9
```

输出：

```
4
```

**思路分析**

二分查找：注意这里的二分查找的while结束条件加上=

**代码**

```java
class Solution {
    public int search(int[] nums, int target) {
        int i = 0, j = nums.length - 1;
        while (i <= j) {
            int mid = i + (j - i) / 2;
            if (nums[mid] > target) {
                j = mid - 1;
            } else if (nums[mid] < target) {
                i = mid + 1;
            } else {
                return mid;
            }
        }
        return -1;

    }
}
```

## 20220421：第一个错误的样本

**题目描述**

你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。

假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。

你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。

**示例**

输入：

```
n = 5, bad = 4
```

输出：

```
4
```

**思路分析**

当isBadVersion(mid)返回为true时，说明当前这个是坏版本，此时j = mid，如果变成mid-1的话可能会错过第一个坏版本，循环终止条件为i < j，保证i==j时退出循环。

**代码**

```java
public class Solution extends VersionControl {
    public int firstBadVersion(int n) {

        int i = 0, j = n;
        while (i < j) {
            int mid = i + (j - i) / 2;
            if (isBadVersion(mid)) {
                j = mid;
            } else {
                i = mid + 1;
            }
        }
        
        return j;
        
    }
}
```

## 20220421：搜索插入位置

**题目描述**

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

请必须使用时间复杂度为 O(log n) 的算法。

**示例**

输入：

```
nums = [1,3,5,6], target = 5
```

输出：

```
2
```

**思路分析**

注意当目标值不在数组中时，需要返回他需要被插入的位置。

**代码**

```java
class Solution {
    public int searchInsert(int[] nums, int target) {

        int i = 0, j = nums.length - 1;
        while (i <= j) {
            int mid = i + (j - i) / 2;
            if (nums[mid] < target) {
                i = mid + 1;
            } else if (nums[mid] > target) {
                j = mid - 1;
            } else {
                return mid;
            }
        }

        return i;

    }
}
```

## 20220422：有序数组的平方

**题目描述**

给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。

**示例**

输入：

```
nums = [-4,-1,0,3,10]
```

输出：

```
[0,1,9,16,100]
```

**思路分析**

双指针，先找到mid最小的值，然后双指针进行比较

**代码**

```java
class Solution {
    public int[] sortedSquares(int[] nums) {

        int mid = 0;
        while (mid < nums.length - 1 && Math.pow(nums[mid], 2) >= Math.pow(nums[mid + 1], 2)) {
            mid++;
        }

        int[] res = new int[nums.length];
        res[0] = (int) Math.pow(nums[mid], 2);

        int i = mid - 1, j = mid + 1;
        int index = 1;
        while (i >= 0 && j < nums.length) {
            if (Math.pow(nums[i], 2) > Math.pow(nums[j], 2)) {
                res[index++] = (int) Math.pow(nums[j++], 2);
            } else {
                res[index++] = (int) Math.pow(nums[i--], 2);
            }
        }

        if (i < 0) {
            for (int k = j; k < nums.length; k++) {
                res[index++] = (int) Math.pow(nums[k], 2);
            }
        }
        if (j == nums.length) {
            for (int k = i; k >= 0; k--) {
                res[index++] = (int) Math.pow(nums[k], 2);
            }
        }


        return res;
    }
}
```

## 20220422：轮转数组

**题目描述**

给你一个数组，将数组中的元素向右轮转 `k` 个位置，其中 `k` 是非负数。

**示例**

输入：

```
nums = [1,2,3,4,5,6,7], k = 3
```

输出：

```
[5,6,7,1,2,3,4]
```

**思路分析**

思路一：使用额外数组，注意++i

思路二：原地反转。先反转整个数组，然后再在k点处断开，分别反转，就是结果。

**代码**

思路一：

```java
class Solution {
    public void rotate(int[] nums, int k) {
        int n = nums.length;
        k %= n;
        int[] res = new int[n];
        int index = 0;
        for (int i = n - k; i < n; i++) {
            res[index++] = nums[i];
        }
        for (int i = 0; i < n - k; i++) {
            res[index++] = nums[i];
        }

        System.arraycopy(res, 0, nums, 0, n);
    }
}
```

思路二：

```java
class Solution {
    public void rotate(int[] nums, int k) {
        k %= nums.length;
        int n = nums.length;
        //反转整个数组
        reverse(nums, 0, n - 1);
        //反转k前面两部分
        reverse(nums, 0, k - 1);
        reverse(nums, k, n - 1);
    }

    public static void reverse(int[] nums, int left, int right) {

        while (left <= right) {
            int tmp = nums[left];
            nums[left] = nums[right];
            nums[right] = tmp;
            left++;
            right--;
        }

    }
}
```

## 20220423：移动零

**题目描述**

给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

请注意 ，必须在不复制数组的情况下原地对数组进行操作。

**示例**

输入：

```
nums = [0,1,0,3,12]
```

输出：

```
[1,3,12,0,0]
```

**思路分析**

复杂一点的题目考虑交换，这里不需要交换，直接将不为0的数字往前移，后面补0即可。

**代码**

```java
class Solution {
    public void moveZeroes(int[] nums) {

        int index = 0;
        int n = nums.length;
        for (int i = 0; i < n; i++) {
            if (nums[i] != 0) {
                nums[index++] = nums[i];
            }
        }

        for (int i = index; i < n; i++) {
            nums[i] = 0;
        }

    }
}
```

## 20220423：两数之和II-输入有序数组

**题目描述**

给你一个下标从 1 开始的整数数组 numbers ，该数组已按 非递减顺序排列  ，请你从数组中找出满足相加之和等于目标数 target 的两个数。如果设这两个数分别是 numbers[index1] 和 numbers[index2] ，则 1 <= index1 < index2 <= numbers.length 。

以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1 和 index2。

你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。

你所设计的解决方案必须只使用常量级的额外空间。

**示例**

输入：

```
numbers = [2,7,11,15], target = 9
```

输出：

```
[1,2]
```

**思路分析**

使用前后双指针即可。

**代码**

```java
class Solution {
    public int[] twoSum(int[] numbers, int target) {

        int i = 0, j = numbers.length - 1;

        while (i < j) {

            if (numbers[i] + numbers[j] > target) {
                j--;
            } else if (numbers[i] + numbers[j] < target) {
                i++;
            } else {
                return new int[]{i + 1, j + 1};
            }
        }
        return new int[]{0, 0};

    }
}
```

## 20220424：反转字符串

**题目描述**

编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。

不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。

**示例**

输入：

```
s = ["h","e","l","l","o"]
```

输出：

```
["o","l","l","e","h"]
```

**思路分析**

无

**代码**

```java
class Solution {
    public void reverseString(char[] s) {
        int i = 0, j = s.length - 1;
        while (i < j) {

            char tmp = s[i];
            s[i] = s[j];
            s[j] = tmp;
            i++;
            j--;
        }

    }
}
```

## 20220424：反转字符串中的单词III

**题目描述**

给定一个字符串 `s` ，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。

**示例**

输入：

```
"Let's take LeetCode contest"
```

输出：

```
"s'teL ekat edoCteeL tsetnoc"
```

**思路分析**

双指针

**代码**

```java
class Solution {
    public String reverseWords(String s) {

        String[] ss = s.split(" ");
        StringBuilder res = new StringBuilder();
        for (int i = 0; i < ss.length; i++) {
            char[] tmp = ss[i].toCharArray();
            reverseString(tmp);
            for (char c : tmp) {
                res.append(c);
            }
            if (i != ss.length - 1) {
                res.append(" ");
            }
        }

        return res.toString();

    }
    public static void reverseString(char[] s) {

        int i = 0, j = s.length - 1;
        while (i < j) {

            char tmp = s[i];
            s[i] = s[j];
            s[j] = tmp;
            i++;
            j--;
        }

    }
}
```

## 20220425：链表的中间结点

**题目描述**

给定一个头结点为 `head` 的非空单链表，返回链表的中间结点。

如果有两个中间结点，则返回第二个中间结点。

**示例**

输入：

```
[1,2,3,4,5]
```

输出：

```
此列表中的结点 3 (序列化形式：[3,4,5])
```

**思路分析**

双指针

**代码**

```java
class Solution {
    public ListNode middleNode(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }

        ListNode low = head, fast = head;
        while (fast != null && fast.next != null) {
            fast = fast.next.next;
            low = low.next;
        }

        return low;

    }
}
```

## 20220425：删除链表的倒数第N个结点

**题目描述**

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

**示例**

输入：

```
head = [1,2,3,4,5], n = 2
```

输出：

```
[1,2,3,5]
```

**思路分析**

需要创建一个虚拟头结点，规避掉一些空指针的问题。

**代码**

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {

        ListNode res = new ListNode(0), dum = res;
        res.next = head;

        ListNode low = dum, fast = dum;

        for (int i = 0; i < n; i++) {
            fast = fast.next;
        }

        while (fast.next != null) {
            fast = fast.next;
            low = low.next;
        }
        low.next = low.next.next;

        return res.next;

    }
}
```

## 20220426：无重复最长子串

**题目描述**

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。

**示例**

输入：

```
s = "abcabcbb"
```

输出：

```
3
```

**思路分析**

滑动窗口，注意left应该取到map.get(s.charAt(i)) + 1，

**代码**

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Map<Character, Integer> map = new HashMap<>();
        int left = 0;
        int max = 0;
        for (int i = 0; i < s.length(); i++) {

            if (map.containsKey(s.charAt(i))) {
                left = Math.max(left, map.get(s.charAt(i)) + 1);
            }

            map.put(s.charAt(i), i);
            max = Math.max(max, i - left + 1);

        }

        return max;
    }
}
```

## 20220426：字符串的排列

**题目描述**

给你两个字符串 s1 和 s2 ，写一个函数来判断 s2 是否包含 s1 的排列。如果是，返回 true ；否则，返回 false 。

换句话说，s1 的排列之一是 s2 的 子串 。

**示例**

输入：

```
s1 = "ab" s2 = "eidbaooo"
```

输出：

```
true
```

**思路分析**

用int[26]的数组去记录s1和s2的每个字符的个数，然后对s2的个数数组进行循环判断。

**代码**

```java
class Solution {
    public boolean checkInclusion(String s1, String s2) {
        if (s1.length() > s2.length()) {
            return false;
        }

        int[] arr1 = new int[26];
        int[] arr2 = new int[26];
        int n = s1.length();

        for (int i = 0; i < n; i++) {
            arr1[s1.charAt(i) - 'a']++;
            arr2[s2.charAt(i) - 'a']++;
        }

        if (Arrays.equals(arr1, arr2)) {
            return true;
        }

        for (int i = 0; i < s2.length() - n; i++) {
            arr2[s2.charAt(i) - 'a']--;
            arr2[s2.charAt(i + n) - 'a']++;
            if (Arrays.equals(arr1, arr2)) {
                return true;
            }
        }

        return false;

    }
}
```

## 20220427：图形渲染

**题目描述**

有一幅以 m x n 的二维整数数组表示的图画 image ，其中 image[i][j] 表示该图画的像素值大小。

你也被给予三个整数 sr ,  sc 和 newColor 。你应该从像素 image[sr][sc] 开始对图像进行 上色填充 。

为了完成 上色工作 ，从初始像素开始，记录初始坐标的 上下左右四个方向上 像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应 四个方向上 像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为 newColor 。

最后返回 经过上色渲染后的图像 。。

**示例**

输入：

```
image = [[1,1,1],[1,1,0],[1,0,1]]，sr = 1, sc = 1, newColor = 2
```

输出：

```
[[2,2,2],[2,2,0],[2,0,1]]
```

**思路分析**

依然是深度优先遍历。

**代码**

```java
class Solution {
    static int[][] images;
    static int color;
    static int m, n;
    static int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
    static boolean[][] visits;
    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {
        images = image;
        m = image.length;
        n = image[0].length;
        color = newColor;
        visits = new boolean[m][n];
        dfs2(sr, sc, images[sr][sc]);

        return images;
    }

    public static void dfs2(int row, int col, int value) {

        if (visits[row][col]) {
            return;
        }

        images[row][col] = color;
        visits[row][col] = true;

        for (int[] dir : dirs) {
            //遍历得到新坐标
            int newRow = row + dir[0];
            int newCol = col + dir[1];
            //上色
            if (newRow >= 0 && newCol >= 0 && newRow <= m - 1 && newCol <= n - 1 && images[newRow][newCol] == value) {
                dfs2(newRow, newCol, value);
            }
        }

    }  
}
```

## 20220427：岛屿的最大面积

**题目描述**

给你一个大小为 m x n 的二进制矩阵 grid 。

岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在 水平或者竖直的四个方向上 相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。

岛屿的面积是岛上值为 1 的单元格的数目。

计算并返回 grid 中最大的岛屿面积。如果没有岛屿，则返回面积为 0 

**示例**

输入：

```
grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]
```

输出：

```
6
```

**思路分析**

深度优先遍历，这里的遍历是有返回值的。

**代码**

```java
class Solution {
    static int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
    public int maxAreaOfIsland(int[][] grid) {

        int max = 0;
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                max = Math.max(max, dfs3(grid, i, j));
            }
        }

        return max;

    }

    public static int dfs3(int[][] grid, int row, int col) {
        //不是土地
        if (grid[row][col] != 1) {
            return 0;
        }
        //表示已经访问过
        grid[row][col] = 0;

        int res = 1;
        for (int[] dir : dirs) {

            int newRow = row + dir[0];
            int newCol = col + dir[1];
            if (newRow >= 0 && newCol >= 0 && newRow <= grid.length - 1 && newCol <= grid[0].length - 1) {
                res += dfs3(grid, newRow, newCol);
            }

        }

        return res;

    }
}
```

## 20220428：合并二叉树

**题目描述**

给你两棵二叉树： root1 和 root2 。

想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。

返回合并后的二叉树。

注意: 合并过程必须从两个树的根节点开始。

**示例**

输入：

```
root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]
```

输出：

```
[3,4,5,5,4,null,7]
```

**思路分析**

深度优先遍历

**代码**

```java
class Solution {
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
        if (root1 == null) {
            return root2;
        }
        if (root2 == null) {
            return root1;
        }

        TreeNode res = new TreeNode(root1.val + root2.val);
        res.left = mergeTrees(root1.left, root2.left);
        res.right = mergeTrees(root1.right, root2.right);

        return res;

    }
}
```

## 20220428：填充每个节点的下一个右侧节点指针

**题目描述**

给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：

struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}

填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。

初始状态下，所有 next 指针都被设置为 NULL。

**示例**

输入：

```
root = [1,2,3,4,5,6,7]
```

输出：

```
[1,#,2,3,#,4,5,6,7,#]
```

**思路分析**

层次遍历

**代码**

```java
class Solution {
    public Node connect(Node root) {
        if (root == null) {
            return root;
        }

        Queue<Node> queue = new LinkedList<>();
        queue.add(root);

        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                Node node = queue.poll();
                if (i < size - 1) {
                    node.next = queue.peek();
                }
                
                if (node.left != null) {
                    queue.add(node.left);
                }
                if (node.right != null) {
                    queue.add(node.right);
                }
            }
        }
        return root;
       
    }
}
```

## 20220429：01矩阵

**题目描述**

给定一个由 0 和 1 组成的矩阵 mat ，请输出一个大小相同的矩阵，其中每一个格子是 mat 中对应位置元素到最近的 0 的距离。

两个相邻元素间的距离为 1 。

**示例**

输入：

```
mat = [[0,0,0],[0,1,0],[0,0,0]]
```

输出：

```
[[0,0,0],[0,1,0],[0,0,0]]
```

**思路分析**

使用广度优先遍历

**代码**

```java
class Solution {
    static int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
    public int[][] updateMatrix(int[][] mat) {

        int m = mat.length;
        int n = mat[0].length;
        int[][] res = new int[m][n];
        boolean[][] judge = new boolean[m][n];
        Queue<int[]> queue = new LinkedList<>();

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                //添加
                if (mat[i][j] == 0) {
                    queue.offer(new int[]{i ,j});
                    judge[i][j] = true;
                }

            }
        }

        while (!queue.isEmpty()) {

            int[] num = queue.poll();
            int row = num[0], col = num[1];
            for (int[] dir : dirs) {
                int newRow = row + dir[0];
                int newCol = col + dir[1];
                if (newRow >= 0 && newRow <= m - 1 && newCol >= 0 && newCol <= n -1 && !judge[newRow][newCol]) {
                    res[newRow][newCol] = res[row][col] + 1;
                    queue.offer(new int[]{newRow, newCol});
                    judge[newRow][newCol] = true;
                }
            }
        }


        return res;

    }
}
```

## 20220429：腐烂的桔子

**题目描述**

在给定的 m x n 网格 grid 中，每个单元格可以有以下三个值之一：

    值 0 代表空单元格；
    值 1 代表新鲜橘子；
    值 2 代表腐烂的橘子。

每分钟，腐烂的橘子 周围 4 个方向上相邻 的新鲜橘子都会腐烂。

返回 直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1 。

**示例**

输入：

```
grid = [[2,1,1],[1,1,0],[0,1,1]]
```

输出：

```
4
```

**思路分析**

广度优先遍历，需要提前记录好桔子的数量，当好桔子数量为0时，退出遍历

**代码**

```java
class Solution {
    static int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
    public int orangesRotting(int[][] grid) {

        int m = grid.length, n = grid[0].length;
        boolean[][] judge = new boolean[m][n];
        Queue<int[]> queue = new LinkedList<>();
        //新鲜桔子的数量
        int count = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    count++;
                }
                if (grid[i][j] == 2) {
                    queue.offer(new int[]{i ,j});
                    judge[i][j] = true;
                }

            }
        }

        int res = 0;

        while (count > 0 && !queue.isEmpty()) {

            int size = queue.size();
            res++;
            for (int i = 0; i < size; i++) {
                int[] poll = queue.poll();
                int row = poll[0];
                int col = poll[1];


                for (int[] dir : dirs) {

                    int newRow = row + dir[0];
                    int newCol = col + dir[1];

                    if (newRow >= 0 && newRow <= m - 1 && newCol >= 0 && newCol <= n - 1 && !judge[newRow][newCol] && grid[newRow][newCol] != 0) {
                        grid[newRow][newCol] = 2;
                        count--;
                        queue.offer(new int[]{newRow, newCol});
                        judge[newRow][newCol] = true;
                    }

                }
            }


        }

        return count > 0 ? -1 : res;

    }
}
```

## 20220430：合并两个有序链表

**题目描述**

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

**示例**

输入：

```
l1 = [1,2,4], l2 = [1,3,4]
```

输出：

```
[1,1,2,3,4,4]
```

**思路分析**

无

**代码**

```java
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {

        if (list1 == null) {
            return list2;
        }
        if (list2 == null) {
            return list1;
        }

        ListNode res = new ListNode(0), dum = res;

        while (list1 != null && list2 != null) {

            if (list1.val < list2.val) {
                dum.next = list1;
                list1 = list1.next;
            } else {
                dum.next = list2;
                list2 = list2.next;
            }
            dum = dum.next;

        }

        dum.next = list1 == null ? list2 : list1;

        return res.next;

    }
}
```

## 20220430：反转链表

**题目描述**

给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

**示例**

输入：

```
head = [1,2,3,4,5]
```

输出：

```
[5,4,3,2,1]
```

**思路分析**

记录当前结点和pre结点即可，循环里再新建next结点

**代码**

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        
        ListNode pre = null;
        ListNode node = head;

        while (node != null) {

            ListNode next = node.next;
            node.next = pre;
            pre = node;
            node = next;
        }

        return pre;

    }
}
```

## 20220515：全排列

**题目描述**

给定两个整数 `n` 和 `k`，返回范围 `[1, n]` 中所有可能的 `k` 个数的组合。

你可以按 **任何顺序** 返回答案。

**示例**

输入：

```
n = 4, k = 2
```

输出：

```
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
```

**思路分析**



**代码**

```java
class Solution {
    static List<List<Integer>> res;
    static List<Integer> list;
    public List<List<Integer>> combine(int n, int k) {

        res = new ArrayList<>();
        list = new ArrayList<>();

        backtracing(1, n, k);

        return res;

    }

    public static void backtracing(int index, int n, int k) {
        if (list.size() == k) {
            res.add(new ArrayList<Integer>(list));
            return;
        }

        for (int i = index; i <= n; i++) {
            list.add(i);
            backtracing(i + 1, n, k);
            list.remove(list.size() - 1);
        }


    }
}
```

## 20220515：全排列

**题目描述**

给定一个不含重复数字的数组 `nums` ，返回其 *所有可能的全排列* 。你可以 **按任意顺序** 返回答案。

**示例**

输入：

```
nums = [1,2,3]
```

输出：

```
[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

**思路分析**



**代码**

```java
class Solution {
    static List<List<Integer>> res;
    static List<Integer> list;
    public List<List<Integer>> permute(int[] nums) {

        int n = nums.length;
        res = new ArrayList<>();
        list = new ArrayList<>();
        boolean[] used = new boolean[n];
        backtracing2(0, used, n, nums);

        return res;

    }

    public static void backtracing2(int index, boolean[] used, int n, int[] nums) {

        if (index == n) {
            res.add(new ArrayList<Integer>(list));
            return;
        }

        for (int i = 0; i < n; i++) {
            if (!used[i]) {
                list.add(nums[i]);
                used[i] = true;
                backtracing2(index + 1, used, n, nums);
                used[i] = false;
                list.remove(list.size() - 1);
            }
        }
        
    }
}
```

## 20220515：字母大小写全排列

**题目描述**

给定一个字符串 `s` ，通过将字符串 `s` 中的每个字母转变大小写，我们可以获得一个新的字符串。

返回 *所有可能得到的字符串集合* 。以 **任意顺序** 返回输出。

**示例**

输入：

```
s = "a1b2"
```

输出：

```
["a1b2", "a1B2", "A1b2", "A1B2"]
```

**思路分析**



**代码**

```java
class Solution {
    public static List<String> letterCasePermutation(String s) {

        List<String> res = new ArrayList<>();
        char[] arr = s.toCharArray();

        backtracing3(0, arr, res);

        return res;

    }

    public static void backtracing3(int index, char[] arr, List<String> res) {
        if (index == arr.length) {
            res.add(new String(arr));
            return;
        }

        backtracing3(index + 1, arr, res);
        if (Character.isLetter(arr[index])) {
            //转化大小写
            arr[index] ^= ' ';
            backtracing3(index + 1, arr, res);
        }

    }

}
```

## 20220516：爬楼梯

**题目描述**

假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**示例**

输入：

```
n = 3
```

输出：

```
3
```

**思路分析**



**代码**

```java
class Solution {
    public int climbStairs(int n) {

        if (n == 1) {
            return 1;
        }

        int[] dp = new int[n + 1];
        dp[1] = 1;
        dp[2] = 2;

        for (int i = 3; i < dp.length; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }

        return dp[n];

    }
}
```

## 20220516：打家劫舍

**题目描述**

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

**示例**

输入：

```
[1,2,3,1]
```

输出：

```
4
```

**思路分析**

`dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);`

**代码**

```java
class Solution {
    public int rob(int[] nums) {

        int n = nums.length;
        if (n == 1) {
            return nums[0];
        }

        int[] dp = new int[n];
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0], nums[1]);
        for (int i = 2; i < n; i++) {
            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);
        }


        return dp[n - 1];

    }
}
```

## 20220516：三角形最小路径和

**题目描述**

给定一个三角形 triangle ，找出自顶向下的最小路径和。

每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/triangle
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

**示例**

输入：

```
triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]
```

输出：

```
11
```

**思路分析**



**代码**

```java
class Solution {
    public int minimumTotal(List<List<Integer>> triangle) {
        int n = triangle.size();
        if (triangle.size() == 1) {
            return triangle.get(0).get(0);
        }

        for (int i = 1; i < n; i++) {
            List<Integer> preList = triangle.get(i - 1);
            List<Integer> curList = triangle.get(i);

            for (int j = 0; j < curList.size(); j++) {
                if (j == 0) {
                    curList.set(j, preList.get(j) + curList.get(j));
                } else if (j == curList.size() - 1) {
                    curList.set(j, preList.get(j - 1) + curList.get(j));
                } else {
                    int min = Math.min(preList.get(j - 1), preList.get(j));
                    curList.set(j, min + curList.get(j));
                }
            }
            triangle.set(i, curList);
        }

        int res = Integer.MAX_VALUE;
        for (Integer integer : triangle.get(triangle.size() - 1)) {
            res = Math.min(res, integer);
        }

        return res;

    }
}
```

## 20220517：2的幂

**题目描述**

给你一个整数 n，请你判断该整数是否是 2 的幂次方。如果是，返回 true ；否则，返回 false 。

如果存在一个整数 x 使得 n == 2x ，则认为 n 是 2 的幂次方。

**示例**

输入：

```
n = 1
```

输出：

```
true
```

**思路分析**

计算n的二进制表达的1的个数，1的个数等于1则为true，否则为false。

**代码**

```java
class Solution {
    public boolean isPowerOfTwo(int n) {

        if (n < 0) {
            return false;
        }

        int count = 0;

        while (n != 0) {
            if ((n & 1) == 1) {
                count++;
            }
            n >>= 1;
        }
        return count == 1;

    }
}
```

## 20220517：位1的个数

**题目描述**

编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为汉明重量）。

 提示：

- 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
  在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。

**示例**

输入：

```
00000000000000000000000000001011
```

输出：

```
3
```

**思路分析**



**代码**

```java
public class Solution {
    // you need to treat n as an unsigned value
    public int hammingWeight(int n) {
        int count = 0;
        for (int i = 0; i < 32; i++) {
            if (((n >>> i) & 1) == 1) {
                count++;
            }
        }
        return count;
    }
}
```

## 20220518：颠倒二进制位

**题目描述**

颠倒给定的 32 位无符号整数的二进制位。

提示：

- 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
  在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。

**示例**

输入：

```
n = 00000010100101000001111010011100
```

输出：

```
964176192 (00111001011110000010100101000000)
```

**思路分析**



**代码**

```java
public class Solution {
    // you need treat n as an unsigned value
    public int reverseBits(int n) {

        int res = 0;
        for (int i = 0; i < 32; i++) {
            res += ((n >>> i) & 1) << (31 - i);
        }
        return res;
    }
}
```

## 20220518：只出现一次的数字

**题目描述**

给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

说明：

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

**示例**

输入：

```
[4,1,2,1,2]
```

输出：

```
4
```

**思路分析**

使用异或(^)，两个数如果^为0，则说明相等。

**代码**

```java
class Solution {
    public int singleNumber(int[] nums) {

        int res = 0;
        for (int i = 0; i < nums.length; i++) {
            res ^= nums[i];
        }
        
        return res;

    }
}
```

## 20220518：在排序数组中查找元素的第一个位置和最后一个位置

**题目描述**

给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 target，返回 [-1, -1]。

进阶：

    你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？

**示例**

输入：

```
nums = [5,7,7,8,8,10], target = 8
```

输出：

```
[3,4]
```

**思路分析**



**代码**

```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int low = searchLow(nums, target);
        int high = searchHigh(nums, target);
        
        if (nums.length < 1 || nums[low] != nums[high] || nums[low] != target || nums[high] != target) {
            return new int[]{-1, -1};
        }


        return new int[]{low, high};

    }

    public static int searchHigh(int[] nums, int target) {

        int i = 0, j = nums.length - 1;
        int res = 0;
        while (i <= j) {
            int mid = i + (j - i) / 2;
            if (nums[mid] <= target) {
                res = mid;
                i = mid + 1;
            } else {
                j = mid - 1;
            }
        }

        return res;


    }

    public static int searchLow(int[] nums, int target) {

        int i = 0, j = nums.length - 1;
        int res = 0;
        while (i <= j) {
            int mid = i + (j - i) / 2;
            if (nums[mid] >= target) {
                res = mid;
                j = mid - 1;
            } else {
                i = mid + 1;
            }
        }

        return res;


    }
}
```

## 20220518：搜索旋转数组

**题目描述**

整数数组 nums 按升序排列，数组中的值 互不相同 。

在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。

给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。

**示例**

输入：

```
nums = [4,5,6,7,0,1,2], target = 0
```

输出：

```
4
```

**思路分析**



**代码**

```java
class Solution {
    public int search(int[] nums, int target) {

        int i = 0, j = nums.length - 1;

        while (i <= j) {
            int mid = i + (j - i) / 2;
            //后半段是按顺序的
            if (nums[mid] < nums[j]) {
                //大于nums[mid]且小于等于nums[j]
                if (target > nums[mid] && target <= nums[j]) {
                    i = mid + 1;
                } else if (target == nums[mid]){
                    return mid;
                } else {
                    j = mid - 1;
                }
            } else { //前半段是按顺序的
                //大于等于nums[i]且小于nums[mid]
                if (target >= nums[i] && target < nums[mid]) {
                    j = mid - 1;
                } else if (target == nums[mid]){
                    return mid;
                } else {
                    i = mid + 1;
                }
            }
        }

        return -1;

    }
}
```

## 20220518：搜索二维数组

**题目描述**

编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：

- 每行中的整数从左到右按升序排列。
- 每行的第一个整数大于前一行的最后一个整数。

**示例**

输入：

```
matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3
```

输出：

```
true
```

**思路分析**



**代码**

```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {

        int m = matrix.length, n = matrix[0].length;
        int i = 0, j = n - 1;

        while (i <= m - 1 && j >= 0) {

            if (matrix[i][j] > target) {
                j--;
            } else if (matrix[i][j] < target) {
                i++;
            } else {
                return true;
            }

        }
        
        return false;

    }
}	
```

## 20220519：搜索旋转的二维数组

**题目描述**

已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：

- 若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]
- 若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]

注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。

给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。

你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。

**示例**

输入：

```
nums = [3,4,5,1,2]
```

输出：

```
1
```

**思路分析**



**代码**

```java
class Solution {
    public int findMin(int[] nums) {

        int min = Integer.MAX_VALUE;
        int i = 0, j = nums.length - 1;

        while (i <= j) {
            int mid = i + (j - i) / 2;
            if (nums[mid] < nums[j]) {
                j = mid;
            } else {
                i = mid + 1;
            }
        }
        
        return nums[j];

    }
}
```

## 20220519：寻找峰值

**题目描述**

峰值元素是指其值严格大于左右相邻值的元素。

给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。

你可以假设 nums[-1] = nums[n] = -∞ 。

你必须实现时间复杂度为 O(log n) 的算法来解决此问题。

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/find-peak-element
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

**示例**

输入：

```
nums = [1,2,3,1]
```

输出：

```
2
```

**思路分析**



**代码**

```java
class Solution {
    public int findPeakElement(int[] nums) {

        if (nums.length == 1) {
            return 0;
        }

        for (int i = 0; i < nums.length; i++) {

            if ((i == 0 && nums[i] > nums[i + 1]) || (i == nums.length - 1 && nums[i] > nums[i - 1])) {
                return i;
            }
            if (i != 0 && i != nums.length - 1 && nums[i] > nums[i - 1] && nums[i] > nums[i + 1]) {
                return i;
            }

        }


        return -1;

    }
}
```

## 20220520：删除链表中的重复元素II

**题目描述**

给定一个已排序的链表的头 `head` ， *删除原始链表中所有重复数字的节点，只留下不同的数字* 。返回 *已排序的链表* 。

**示例**

输入：

```
head = [1,2,3,3,4,4,5]
```

输出：

```
[1,2,5]
```

**思路分析**



**代码**

```java
class Solution {
    public ListNode deleteDuplicates(ListNode head) {

        if (head == null || head.next == null) {
            return head;
        }

        ListNode node = head;
        Map<Integer, Integer> map = new HashMap<>();

        while (node != null) {
            int count = map.getOrDefault(node.val, 0) + 1;
            map.put(node.val, count);
            node = node.next;
        }

        ListNode res = new ListNode(0);
        res.next = head;

        ListNode pre = res;
        ListNode cur = head;
        
        while (cur != null) {
            if (map.get(cur.val) != 1) {
                pre.next = cur.next;
                cur = cur.next;
            } else {
                pre = pre.next;
                cur = cur.next;
            }
        }
        return res.next;

    }
}
```

## 20220520：三数之和

**题目描述**

给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。

注意：答案中不可以包含重复的三元组。

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/3sum
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

**示例**

输入：

```
nums = [-1,0,1,2,-1,-4]
```

输出：

```
[[-1,-1,2],[-1,0,1]]
```

**思路分析**



**代码**

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {

        List<List<Integer>> res = new ArrayList<>();
        if (nums.length < 3) {
            return res;
        }

        Arrays.sort(nums);

        //第一层循环
        for (int k = 0; k < nums.length - 2; k++) {
            int i = k + 1, j = nums.length - 1;
            if (k > 0 && nums[k] == nums[k - 1]) {
                continue;
            }
            if (nums[k] + nums[k + 1] + nums[k + 2] > 0) {
                continue;
            }
            if (nums[k] + nums[j - 1] + nums[j] < 0) {
                continue;
            }
            while (i < j) {
                int sum = nums[k] + nums[i] + nums[j];
                if (sum < 0) {
                    while (i < j && nums[i] == nums[++i]);
                } else if (sum > 0) {
                    while (i < j && nums[j] == nums[--j]);
                } else {
                    res.add(Arrays.asList(nums[k], nums[i], nums[j]));
                    while (i < j && nums[i] == nums[++i]);
                    while (i < j && nums[j] == nums[--j]);
                }
            }
        }

        return res;

    }
}
```

## 20220521：比较含退格的字符串

**题目描述**

给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 true 。# 代表退格字符。

注意：如果对空文本输入退格字符，文本继续为空。

**示例**

输入：

```
s = "ab#c", t = "ad#c"
```

输出：

```
true
```

**思路分析**



**代码**

```java
class Solution {
    public boolean backspaceCompare(String s, String t) {

        return backSpace(s).equals(backSpace(t));

    }

    public static String backSpace(String s) {

        Deque<Character> queue = new LinkedList<>();

        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (!queue.isEmpty() && c == '#') {
                queue.pollLast();
            } else if (c != '#') {
                queue.offerLast(c);
            }

        }


        return queue.toString();
    }
}
```

## 20220521：

**题目描述**

给定两个由一些 闭区间 组成的列表，firstList 和 secondList ，其中 firstList[i] = [starti, endi] 而 secondList[j] = [startj, endj] 。每个区间列表都是成对 不相交 的，并且 已经排序 。

返回这 两个区间列表的交集 。

形式上，闭区间 [a, b]（其中 a <= b）表示实数 x 的集合，而 a <= x <= b 。

两个闭区间的 交集 是一组实数，要么为空集，要么为闭区间。例如，[1, 3] 和 [2, 4] 的交集为 [2, 3] 。

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/interval-list-intersections
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

**示例**

输入：

```
firstList = [[0,2],[5,10],[13,23],[24,25]], secondList = [[1,5],[8,12],[15,24],[25,26]]
```

输出：

```
[[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]
```

**思路分析**

取并集可以用Max和Min函数

**代码**

```java
class Solution {
    public int[][] intervalIntersection(int[][] firstList, int[][] secondList) {

        if (firstList.length == 0 || secondList.length == 0) {
            return new int[0][0];
        }

        List<int[]> tmp = new ArrayList<>();


        int i = 0, j = 0;

        while (i < firstList.length && j < secondList.length) {

            int lo = Math.max(firstList[i][0], secondList[j][0]);
            int hi = Math.min(firstList[i][1], secondList[j][1]);

            if (lo <= hi) {
                tmp.add(new int[]{lo, hi});
            }

            if (firstList[i][1] < secondList[j][1]) {
                i++;
            } else {
                j++;
            }

        }

        return tmp.toArray(new int[tmp.size()][2]);

    }
}
```

## 20220521：盛最多水的容器

**题目描述**

给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。

找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

返回容器可以储存的最大水量。

说明：你不能倾斜容器。

**示例**

输入：

```
[1,8,6,2,5,4,8,3,7]
```

输出：

```
49
```

**思路分析**

双指针

**代码**

```java
class Solution {
    public int maxArea(int[] height) {
        int res = 0;

        int i = 0, j = height.length - 1;
        while (i <= j) {

            res = Math.max(res, Math.min(height[i], height[j]) * (j - i));
            if (height[i] < height[j]) {
                i++;
            } else {
                j--;
            }

        }

        return res;

    }
}
```

## 20220523：找到字符串中所有的字母异位词

**题目描述**

给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。

异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。

**示例**

输入：

```
s = "cbaebabacd", p = "abc"
```

输出：

```
[0,6]
```

**思路分析**

取出字符串所有的子串排序与排序后的目标串比较。

**代码**

```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {

        List<Integer> res = new ArrayList<>();

        if (p.length() == 0) {
            return res;
        }
        char[] c = p.toCharArray();
        Arrays.sort(c);
        p = new String(c);

        for (int i = 0; i < s.length() - p.length() + 1; i++) {
            if (check(s.substring(i, i + p.length()), p)) {
                res.add(i);
            }
        }

        return res;

    }

    public static boolean check(String subString, String p) {
        char[] c = subString.toCharArray();
        Arrays.sort(c);
        return new String(c).equals(p);
    }
}
```

## 20220523：乘积小于k的子数组

**题目描述**

给你一个整数数组 `nums` 和一个整数 `k` ，请你返回子数组内所有元素的乘积严格小于 `k` 的连续子数组的数目。

**示例**

输入：

```
nums = [10,5,2,6], k = 100
```

输出：

```
8
```

**思路分析**

滑动窗口

**代码**

```java
class Solution {
    public int numSubarrayProductLessThanK(int[] nums, int k) {

        int res = 0;
        int prod = 1;
        int left = 0;
        for (int i = 0; i < nums.length; i++) {
            prod *= nums[i];
            while (left <= i && prod >= k) {
                prod /= nums[left];
                left++;
            }
            res += i - left + 1;

        }

        return res;

    }
}
```

## 20220523：长度最小的子数组

**题目描述**

给定一个含有 n 个正整数的数组和一个正整数 target 。

找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。

**示例**

输入：

```
target = 7, nums = [2,3,1,2,4,3]
```

输出：

```
2
```

**思路分析**

滑动窗口

**代码**

```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {

        int sum = 0;
        int i = 0;
        int res = Integer.MAX_VALUE;
        for (int j = 0; j < nums.length; j++) {
            sum += nums[j];
            while (i <= j && sum >= target) {
                res = Math.min(res, j - i + 1);
                sum -= nums[i];
                i++;
            }

        }

        return res == Integer.MAX_VALUE ? 0 : res;
    }
}
```

## 20220523：岛屿数量

**题目描述**

给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

**示例**

输入：

```
grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
```

输出：

```
3
```

**思路分析**

深度优先遍历

**代码**

```java
class Solution {
    public int numIslands(char[][] grid) {

        int m = grid.length, n = grid[0].length;
        int[][] dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        boolean[][] visited = new boolean[m][n];
        int res = 0;

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (!visited[i][j] && grid[i][j] == '1') {
                    dfs(i, j, grid, dirs, visited);
                    res++;
                }
            }
        }

        return res;

    }

    public static void dfs(int i, int j, char[][] grid, int[][] dirs, boolean[][] visited) {

        visited[i][j] = true;
        for (int[] dir : dirs) {

            int newRow = i + dir[0];
            int newCol = j + dir[1];

            if (newRow >= 0 && newCol >= 0 && newRow <= grid.length - 1 && newCol <= grid[0].length - 1 && !visited[newRow][newCol] && grid[newRow][newCol] == '1') {
                dfs(newRow, newCol, grid, dirs, visited);
            }
        }

    }
}
```

## 20220523：省份数量

**题目描述**

有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。

省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。

给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。

返回矩阵中 省份 的数量。

**示例**

输入：

```
isConnected = [[1,1,0],[1,1,0],[0,0,1]]
```

输出：

```
2
```

**思路分析**

深度优先遍历，将所有一个城市的先遍历出来。

**代码**

```java
class Solution {
    public int findCircleNum(int[][] isConnected) {

        int cities = isConnected.length;
        boolean[] visited = new boolean[cities];
        int provinces = 0;

        for (int i = 0; i < cities; i++) {
            if (!visited[i]) {
                dfs2(isConnected, visited, cities, i);
                provinces++;
            }


        }

        return provinces;

    }

    public static void dfs2(int[][] isConnected, boolean[] visited, int cities, int i) {

        for (int j = 0; j < cities; j++) {
            if (isConnected[i][j] == 1 && !visited[j]) {
                visited[j] = true;
                dfs2(isConnected, visited, cities, j);
            }

        }

    }
}
```

## 20220524：填充每个节点的下一个右侧节点指针II

**题目描述**

给定一个二叉树

```
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。

初始状态下，所有 next 指针都被设置为 NULL。

 进阶：

- 你只能使用常量级额外空间。
- 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。

**示例**

输入：

```
root = [1,2,3,4,5,null,7]
```

输出：

```
[1,#,2,3,#,4,5,7,#]
```

**思路分析**

层次遍历

**代码**

```java
class Solution {
    public Node connect(Node root) {

        if (root == null) {
            return null;
        }

        Queue<Node> queue = new LinkedList<>();
        queue.add(root);
        while (!queue.isEmpty()) {
            int size = queue.size();
            Node pre = null;
            for (int i = 0; i < size; i++) {
                Node cur = queue.poll();
                if (cur.left != null) {
                    queue.offer(cur.left);
                }
                if (cur.right != null) {
                    queue.offer(cur.right);
                }
                if (i != 0) {
                    pre.next = cur;
                }
                pre = cur;
            }
        }
        return root;
        
    }
}
```

## 20220524：另一棵树的子树

**题目描述**

给你两棵二叉树 root 和 subRoot 。检验 root 中是否包含和 subRoot 具有相同结构和节点值的子树。如果存在，返回 true ；否则，返回 false 。

二叉树 tree 的一棵子树包括 tree 的某个节点和这个节点的所有后代节点。tree 也可以看做它自身的一棵子树。

**示例**

输入：

```
root = [3,4,5,1,2], subRoot = [4,1,2]
```

输出：

```
true
```

**思路分析**

递归

**代码**

```java
class Solution {
    public boolean isSubtree(TreeNode root, TreeNode subRoot) {

        if (root == null) {
            return false;
        }
        return check(root, subRoot) || isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot);

    }

    public static boolean check(TreeNode s, TreeNode t) {

        if (s == null && t == null) {
            return true;
        }
        if (s == null || t == null || s.val != t.val) {
            return false;
        }

        return check(s.left, t.left) && check(s.right, t.right);

    }
}
```

## 20220525：二进制矩阵中的最短路径

**题目描述**

给你一个 n x n 的二进制矩阵 grid 中，返回矩阵中最短 畅通路径 的长度。如果不存在这样的路径，返回 -1 。

二进制矩阵中的 畅通路径 是一条从 左上角 单元格（即，(0, 0)）到 右下角 单元格（即，(n - 1, n - 1)）的路径，该路径同时满足下述要求：

- 路径途经的所有单元格都的值都是 0 。
- 路径中所有相邻的单元格应当在 8 个方向之一 上连通（即，相邻两单元之间彼此不同且共享一条边或者一个角）。

畅通路径的长度 是该路径途经的单元格总数。

**示例**

输入：

```
grid = [[0,0,0],[1,1,0],[1,1,0]]
```

输出：

```
4
```

**思路分析**

BFS

**代码**

```java
class Solution {
    public int shortestPathBinaryMatrix(int[][] grid) {

        if (grid[0][0] == 1) {
            return -1;
        }

        int n = grid.length;
        int[][] paths = {{1, 0}, {0, 1}, {1, 1}, {-1, 1}, {1, -1}, {-1, 0}, {0, -1}, {-1, -1}};
        boolean[][] judge = new boolean[n][n];
        int[][] dp = new int[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                dp[i][j] = Integer.MAX_VALUE;
            }
        }
        dp[0][0] = 1;
        Queue<int[]> queue = new LinkedList<>();
        queue.add(new int[]{0, 0});

        while (!queue.isEmpty()) {
            int[] cur = queue.poll();
            for (int[] path : paths) {
                int newRow = cur[0] + path[0];
                int newCol = cur[1] + path[1];
                if (newRow >= 0 && newRow <= n - 1 && newCol >= 0 && newCol <= n - 1 && grid[newRow][newCol] == 0 && !judge[newRow][newCol]) {
                    judge[newRow][newCol] = true;
                    dp[newRow][newCol] = Math.min(dp[cur[0]][cur[1]] + 1, dp[newRow][newCol]);
                    queue.add(new int[]{newRow, newCol});

                }
            }
        }

        return dp[n - 1][n - 1] == Integer.MAX_VALUE ? -1 : dp[n - 1][n - 1];

    }
}
```

## 20220525：被围绕的区域

**题目描述**

给你一个 m x n 的矩阵 board ，由若干字符 'X' 和 'O' ，找到所有被 'X' 围绕的区域，并将这些区域里所有的 'O' 用 'X' 填充。

**示例**

输入：

```
board = [["X","X","X","X"],["X","O","O","X"],["X","X","O","X"],["X","O","X","X"]]
```

输出：

```
[["X","X","X","X"],["X","X","X","X"],["X","X","X","X"],["X","O","X","X"]]
```

**思路分析**

https://leetcode.cn/problems/surrounded-regions/solution/bei-wei-rao-de-qu-yu-by-leetcode-solution/

**代码**

```java
class Solution {
    static int n, m;
    public static void solve(char[][] board) {
        n = board.length;
        if (n == 0) {
            return;
        }
        m = board[0].length;
        for (int i = 0; i < n; i++) {
            dfs(board, i, 0);
            dfs(board, i, m - 1);
        }
        for (int i = 1; i < m - 1; i++) {
            dfs(board, 0, i);
            dfs(board, n - 1, i);
        }
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (board[i][j] == 'A') {
                    board[i][j] = 'O';
                } else if (board[i][j] == 'O') {
                    board[i][j] = 'X';
                }
            }
        }
        
    }

    public static void dfs(char[][] board, int x, int y) {
        if (x < 0 || x >= n || y < 0 || y >= m || board[x][y] != 'O') {
            return;
        }
        board[x][y] = 'A';
        dfs(board, x + 1, y);
        dfs(board, x - 1, y);
        dfs(board, x, y + 1);
        dfs(board, x, y - 1);
    }
}
```

## 20220525：所有可能的路径

**题目描述**

给你一个有 n 个节点的 有向无环图（DAG），请你找出所有从节点 0 到节点 n-1 的路径并输出（不要求按特定顺序）

 graph[i] 是一个从节点 i 可以访问的所有节点的列表（即从节点 i 到节点 graph[i][j]存在一条有向边）。

**示例**

输入：

```
graph = [[1,2],[3],[3],[]]
```

输出：

```
[[0,1,3],[0,2,3]]
```

**思路分析**

https://leetcode.cn/problems/all-paths-from-source-to-target/solution/suo-you-ke-neng-de-lu-jing-by-leetcode-s-iyoh/

**代码**

```java
class Solution {
    List<List<Integer>> ans = new ArrayList<List<Integer>>();
    Deque<Integer> stack = new ArrayDeque<Integer>();

    public List<List<Integer>> allPathsSourceTarget(int[][] graph) {
        stack.offerLast(0);
        dfs(graph, 0, graph.length - 1);
        return ans;
    }

    public void dfs(int[][] graph, int x, int n) {
        if (x == n) {
            ans.add(new ArrayList<Integer>(stack));
            return;
        }
        for (int y : graph[x]) {
            stack.offerLast(y);
            dfs(graph, y, n);
            stack.pollLast();
        }
    }
}
```

## 20220526：子集

**题目描述**

给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。

解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。

**示例**

输入：

```
nums = [1,2,3]
```

输出：

```
[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
```

**思路分析**



**代码**

```java
class Solution {
    public static List<List<Integer>> subsets(int[] nums) {

        List<List<Integer>> res = new ArrayList<>();
        List<Integer> list = new ArrayList<>();
        dfs(res, nums, list, 0);
        return res;

    }

    public static void dfs(List<List<Integer>> res, int[] nums, List<Integer> list, int cur) {

        if (cur == nums.length) {
            res.add(new ArrayList<>(list));
            return;
        }

        list.add(nums[cur]);
        dfs(res, nums, list, cur + 1);
        list.remove(list.size() - 1);
        dfs(res, nums, list, cur + 1);

    }
}
```

## 20220526：子集II

**题目描述**

给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。

解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。

**示例**

输入：

```
nums = [1,2,2]
```

输出：

```
[[],[1],[1,2],[1,2,2],[2],[2,2]]
```

**思路分析**

跟之前的思路类似，只不过需要先将nums排序，然后如果当前元素和之前元素重复，则跳过。

**代码**

```java
class Solution {
    public List<List<Integer>> subsetsWithDup(int[] nums) {

        List<List<Integer>> res = new ArrayList<>();
        List<Integer> list = new ArrayList<>();
        Arrays.sort(nums);
        dfs2(res, nums, list, 0, false);
        return res;

    }

    public static void dfs2(List<List<Integer>> res, int[] nums, List<Integer> list, int cur, boolean isDup) {

        if (cur == nums.length) {
            res.add(new ArrayList<>(list));
            return;
        }

        dfs2(res, nums, list, cur + 1, false);
        if (!isDup && cur > 0 && nums[cur - 1] == nums[cur]) {
            return;
        }
        list.add(nums[cur]);
        dfs2(res, nums, list, cur + 1, true);
        list.remove(list.size() - 1);

    }
}
```

## 20220527：全排列II

**题目描述**

给定一个可包含重复数字的序列 `nums` ，***按任意顺序*** 返回所有不重复的全排列。

**示例**

输入：

```
nums = [1,1,2]
```

输出：

```
[[1,1,2],
 [1,2,1],
 [2,1,1]]
```

**思路分析**



**代码**

```java
class Solution {
    public List<List<Integer>> permuteUnique(int[] nums) {

        List<List<Integer>> res = new ArrayList<>();
        List<Integer> path = new ArrayList<>();
        boolean[] visited = new boolean[nums.length];
        Arrays.sort(nums);
        backtracing(res, path, visited, nums, 0);

        return res;

    }

    public static void backtracing(List<List<Integer>> res, List<Integer> path, boolean[] visited, int[] nums, int index) {

        if (index == nums.length) {
            res.add(new ArrayList<>(path));
        }

        for (int i = 0; i < nums.length; i++) {

            if (visited[i] || (i > 0 && nums[i] == nums[i - 1] && !visited[i - 1])) {
                continue;
            }

            path.add(nums[i]);
            visited[i] = true;
            backtracing(res, path, visited, nums, index + 1);
            visited[i] = false;
            path.remove(index);
        }



    }
}
```

## 20220527：组合总和

**题目描述**

给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。

candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 

对于给定的输入，保证和为 target 的不同组合数少于 150 个。

**示例**

输入：

```
candidates = [2,3,6,7], target = 7
```

输出：

```
[[2,2,3],[7]]
```

**思路分析**



**代码**

```java
class Solution {
    List<List<Integer>> res;
    LinkedList<Integer> nums;
    int[] candidates;
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        this.res = new ArrayList<>();
        this.nums = new LinkedList<>();
        this.candidates = candidates;
        recur(0,target);
        return res;
    }

    public void recur(int k,int target){
        if(target==0){
            res.add(new LinkedList<Integer>(nums));
            return;
        }
        if(target<0) return;

        for(int i=k; i<candidates.length; i++){
            nums.addLast(candidates[i]);
            recur(i,target-candidates[i]);
            nums.removeLast();
        }
    }

}
```

## 20220527：组合总和II

**题目描述**

定一个可包含重复数字的序列 `nums` ，***按任意顺序*** 返回所有不重复的全排列。

**示例**

输入：

```
nums = [1,1,2]
```

输出：

```
[[1,1,2],
 [1,2,1],
 [2,1,1]]
```

**思路分析**



**代码**

```java
class Solution {
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {

        int len = candidates.length;
        List<List<Integer>> res = new ArrayList<>();
        if (len == 0) {
            return res;
        }

        Arrays.sort(candidates);

        Deque<Integer> path = new ArrayDeque<>(len);
        dfs(candidates, len, 0, target, path, res);
        return res;

    }

    private static void dfs(int[] candidates, int len, int begin, int target, Deque<Integer> path, List<List<Integer>> res) {
        if (target == 0) {
            res.add(new ArrayList<>(path));
            return;
        }
        for (int i = begin; i < len; i++) {
            // 大剪枝：减去 candidates[i] 小于 0，减去后面的 candidates[i + 1]、candidates[i + 2] 肯定也小于 0，因此用 break
            if (target - candidates[i] < 0) {
                break;
            }
            // 小剪枝：同一层相同数值的结点，从第 2 个开始，候选数更少，结果一定发生重复，因此跳过，用 continue
            if (i > begin && candidates[i] == candidates[i - 1]) {
                continue;
            }
            path.addLast(candidates[i]);
            // 因为元素不可以重复使用，这里递归传递下去的是 i + 1 而不是 i
            dfs(candidates, len, i + 1, target - candidates[i], path, res);

            path.removeLast();
        }
    }
}
```

## 20220528：电话号码的字母组合

**题目描述**

给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

**示例**

输入：

```
digits = "23"
```

输出：

```
["ad","ae","af","bd","be","bf","cd","ce","cf"]
```

**思路分析**



**代码**

```java
class Solution {
    static List<String> res;
    static Map<Character, String> map;
    static StringBuilder sb;
    static char[] c;
    public List<String> letterCombinations(String digits) {

        if (digits.length() == 0) {
            return new ArrayList<>();
        }

        map = new HashMap<>(){{
            put('2',"abc");
            put('3',"def");
            put('4',"ghi");
            put('5',"jkl");
            put('6',"mno");
            put('7',"pqrs");
            put('8',"tuv");
            put('9',"wxyz");
        }};

        res = new LinkedList<>();
        sb = new StringBuilder();

        c = digits.toCharArray();

        backtracing(0);

        return res;

    }


    public static void backtracing(int index) {

        if (index == c.length) {
            res.add(sb.toString());
            return;
        }

        String s = map.get(c[index]);
        int count = map.get(c[index]).length();

        for (int i = 0; i < count; i++) {
            sb.append(s.charAt(i));
            backtracing(index + 1);
            sb.deleteCharAt(index);
        }

    }
}
```

## 20220528：括号生成

**题目描述**

数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。

**示例**

输入：

```
n=3
```

输出：

```
["((()))","(()())","(())()","()(())","()()()"]
```

**思路分析**



**代码**

```java
class Solution {
    static List<String> res;
    static StringBuilder sb;
    public List<String> generateParenthesis(int n) {
        res = new LinkedList<>();
        sb = new StringBuilder();

        backtarcing(n, 0, 0);
        return res;

    }

    //i为左括号数， j为右括号数
    public static void backtarcing(int n, int i, int j) {
        if (i < j) {
            return;
        }
        if (i == n && j == n) {
            res.add(sb.toString());
        }
        if (i < n) {
            sb.append("(");
            backtarcing(n, i + 1, j);
            sb.deleteCharAt(sb.length() - 1);
        }
        if (j < n) {
            sb.append(")");
            backtarcing(n, i, j + 1);
            sb.deleteCharAt(sb.length() - 1);
        }


    }
}
```

## 20220528：单词搜索

**题目描述**

给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

**示例**

输入：

```
board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
```

输出：

```
true
```

**思路分析**



**代码**

```java
class Solution {
    public boolean exist(char[][] board, String word) {

        int N = board.length, M = board[0].length;
        for(int i=0; i<N; i++){
            for(int j=0; j<M; j++){
                if(backtracing(board,word,i,j,0)) return true;
            }
        }
        return false;

    }

    public boolean backtracing(char[][] board, String word, int i, int j, int k){
        if(i<0 || j<0 || i>=board.length || j>=board[0].length || board[i][j] != word.charAt(k)){
            return false;
        }
        if(k==word.length()-1) return true;
        board[i][j]='\0';
        boolean res = backtracing(board,word,i+1,j,k+1) ||backtracing(board,word,i-1,j,k+1) || backtracing(board,word,i,j-1,k+1) || backtracing(board,word,i,j+1,k+1);
        board[i][j]=word.charAt(k);
        return res;


    }

}
```

## 20220529：打家劫舍II

**题目描述**

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。

给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。

**示例**

输入：

```
nums = [2,3,2]
```

输出：

```
3
```

**思路分析**



**代码**

```java
class Solution {
    public int rob(int[] nums) {
        int length = nums.length;
        if (length == 1) {
            return nums[0];
        } else if (length == 2) {
            return Math.max(nums[0], nums[1]);
        }
        return Math.max(robRange(nums, 0, length - 2), robRange(nums, 1, length - 1));
    }

    public int robRange(int[] nums, int start, int end) {
        int first = nums[start], second = Math.max(nums[start], nums[start + 1]);
        for (int i = start + 2; i <= end; i++) {
            int temp = second;
            second = Math.max(first + nums[i], second);
            first = temp;
        }
        return second;
    }

}
```

## 20220529：跳跃游戏

**题目描述**

给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标。

**示例**

输入：

```
nums = [2,3,1,1,4]
```

输出：

```
true
```

**思路分析**



**代码**

```java
class Solution {
    public boolean canJump(int[] nums) {
        int max=0;
        for(int i=0; i<=max; i++){
            max=Math.max(max,i+nums[i]);
            if(max>=nums.length-1) return true;
        }

        return false;

    }
}
```



















































## 20220529：

**题目描述**



**示例**

输入：

```

```

输出：

```

```

**思路分析**



**代码**

```java

```

