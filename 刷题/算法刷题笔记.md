## 20220421：二分查找

**题目描述**

给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

**示例**

输入：

```
nums = [-1,0,3,5,9,12], target = 9
```

输出：

```
4
```

**思路分析**

二分查找：注意这里的二分查找的while结束条件加上=

**代码**

```java
class Solution {
    public int search(int[] nums, int target) {
        int i = 0, j = nums.length - 1;
        while (i <= j) {
            int mid = i + (j - i) / 2;
            if (nums[mid] > target) {
                j = mid - 1;
            } else if (nums[mid] < target) {
                i = mid + 1;
            } else {
                return mid;
            }
        }
        return -1;

    }
}
```

## 20220421：第一个错误的样本

**题目描述**

你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。

假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。

你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。

**示例**

输入：

```
n = 5, bad = 4
```

输出：

```
4
```

**思路分析**

当isBadVersion(mid)返回为true时，说明当前这个是坏版本，此时j = mid，如果变成mid-1的话可能会错过第一个坏版本，循环终止条件为i < j，保证i==j时退出循环。

**代码**

```java
public class Solution extends VersionControl {
    public int firstBadVersion(int n) {

        int i = 0, j = n;
        while (i < j) {
            int mid = i + (j - i) / 2;
            if (isBadVersion(mid)) {
                j = mid;
            } else {
                i = mid + 1;
            }
        }
        
        return j;
        
    }
}
```

## 20220421：搜索插入位置

**题目描述**

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

请必须使用时间复杂度为 O(log n) 的算法。

**示例**

输入：

```
nums = [1,3,5,6], target = 5
```

输出：

```
2
```

**思路分析**

注意当目标值不在数组中时，需要返回他需要被插入的位置。

**代码**

```java
class Solution {
    public int searchInsert(int[] nums, int target) {

        int i = 0, j = nums.length - 1;
        while (i <= j) {
            int mid = i + (j - i) / 2;
            if (nums[mid] < target) {
                i = mid + 1;
            } else if (nums[mid] > target) {
                j = mid - 1;
            } else {
                return mid;
            }
        }

        return i;

    }
}
```

## 20220422：有序数组的平方

**题目描述**

给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。

**示例**

输入：

```
nums = [-4,-1,0,3,10]
```

输出：

```
[0,1,9,16,100]
```

**思路分析**

双指针，先找到mid最小的值，然后双指针进行比较

**代码**

```java
class Solution {
    public int[] sortedSquares(int[] nums) {

        int mid = 0;
        while (mid < nums.length - 1 && Math.pow(nums[mid], 2) >= Math.pow(nums[mid + 1], 2)) {
            mid++;
        }

        int[] res = new int[nums.length];
        res[0] = (int) Math.pow(nums[mid], 2);

        int i = mid - 1, j = mid + 1;
        int index = 1;
        while (i >= 0 && j < nums.length) {
            if (Math.pow(nums[i], 2) > Math.pow(nums[j], 2)) {
                res[index++] = (int) Math.pow(nums[j++], 2);
            } else {
                res[index++] = (int) Math.pow(nums[i--], 2);
            }
        }

        if (i < 0) {
            for (int k = j; k < nums.length; k++) {
                res[index++] = (int) Math.pow(nums[k], 2);
            }
        }
        if (j == nums.length) {
            for (int k = i; k >= 0; k--) {
                res[index++] = (int) Math.pow(nums[k], 2);
            }
        }


        return res;
    }
}
```

## 20220422：轮转数组

**题目描述**

给你一个数组，将数组中的元素向右轮转 `k` 个位置，其中 `k` 是非负数。

**示例**

输入：

```
nums = [1,2,3,4,5,6,7], k = 3
```

输出：

```
[5,6,7,1,2,3,4]
```

**思路分析**

思路一：使用额外数组，注意++i

思路二：原地反转。先反转整个数组，然后再在k点处断开，分别反转，就是结果。

**代码**

思路一：

```java
class Solution {
    public void rotate(int[] nums, int k) {
        int n = nums.length;
        k %= n;
        int[] res = new int[n];
        int index = 0;
        for (int i = n - k; i < n; i++) {
            res[index++] = nums[i];
        }
        for (int i = 0; i < n - k; i++) {
            res[index++] = nums[i];
        }

        System.arraycopy(res, 0, nums, 0, n);
    }
}
```

思路二：

```java
class Solution {
    public void rotate(int[] nums, int k) {
        k %= nums.length;
        int n = nums.length;
        //反转整个数组
        reverse(nums, 0, n - 1);
        //反转k前面两部分
        reverse(nums, 0, k - 1);
        reverse(nums, k, n - 1);
    }

    public static void reverse(int[] nums, int left, int right) {

        while (left <= right) {
            int tmp = nums[left];
            nums[left] = nums[right];
            nums[right] = tmp;
            left++;
            right--;
        }

    }
}
```

## 20220423：移动零

**题目描述**

给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

请注意 ，必须在不复制数组的情况下原地对数组进行操作。

**示例**

输入：

```
nums = [0,1,0,3,12]
```

输出：

```
[1,3,12,0,0]
```

**思路分析**

复杂一点的题目考虑交换，这里不需要交换，直接将不为0的数字往前移，后面补0即可。

**代码**

```java
class Solution {
    public void moveZeroes(int[] nums) {

        int index = 0;
        int n = nums.length;
        for (int i = 0; i < n; i++) {
            if (nums[i] != 0) {
                nums[index++] = nums[i];
            }
        }

        for (int i = index; i < n; i++) {
            nums[i] = 0;
        }

    }
}
```

## 20220423：两数之和II-输入有序数组

**题目描述**

给你一个下标从 1 开始的整数数组 numbers ，该数组已按 非递减顺序排列  ，请你从数组中找出满足相加之和等于目标数 target 的两个数。如果设这两个数分别是 numbers[index1] 和 numbers[index2] ，则 1 <= index1 < index2 <= numbers.length 。

以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1 和 index2。

你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。

你所设计的解决方案必须只使用常量级的额外空间。

**示例**

输入：

```
numbers = [2,7,11,15], target = 9
```

输出：

```
[1,2]
```

**思路分析**

使用前后双指针即可。

**代码**

```java
class Solution {
    public int[] twoSum(int[] numbers, int target) {

        int i = 0, j = numbers.length - 1;

        while (i < j) {

            if (numbers[i] + numbers[j] > target) {
                j--;
            } else if (numbers[i] + numbers[j] < target) {
                i++;
            } else {
                return new int[]{i + 1, j + 1};
            }
        }
        return new int[]{0, 0};

    }
}
```

## 20220424：反转字符串

**题目描述**

编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。

不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。

**示例**

输入：

```
s = ["h","e","l","l","o"]
```

输出：

```
["o","l","l","e","h"]
```

**思路分析**

无

**代码**

```java
class Solution {
    public void reverseString(char[] s) {
        int i = 0, j = s.length - 1;
        while (i < j) {

            char tmp = s[i];
            s[i] = s[j];
            s[j] = tmp;
            i++;
            j--;
        }

    }
}
```

## 20220424：反转字符串中的单词III

**题目描述**

给定一个字符串 `s` ，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。

**示例**

输入：

```
"Let's take LeetCode contest"
```

输出：

```
"s'teL ekat edoCteeL tsetnoc"
```

**思路分析**

双指针

**代码**

```java
class Solution {
    public String reverseWords(String s) {

        String[] ss = s.split(" ");
        StringBuilder res = new StringBuilder();
        for (int i = 0; i < ss.length; i++) {
            char[] tmp = ss[i].toCharArray();
            reverseString(tmp);
            for (char c : tmp) {
                res.append(c);
            }
            if (i != ss.length - 1) {
                res.append(" ");
            }
        }

        return res.toString();

    }
    public static void reverseString(char[] s) {

        int i = 0, j = s.length - 1;
        while (i < j) {

            char tmp = s[i];
            s[i] = s[j];
            s[j] = tmp;
            i++;
            j--;
        }

    }
}
```

## 20220425：链表的中间结点

**题目描述**

给定一个头结点为 `head` 的非空单链表，返回链表的中间结点。

如果有两个中间结点，则返回第二个中间结点。

**示例**

输入：

```
[1,2,3,4,5]
```

输出：

```
此列表中的结点 3 (序列化形式：[3,4,5])
```

**思路分析**

双指针

**代码**

```java
class Solution {
    public ListNode middleNode(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }

        ListNode low = head, fast = head;
        while (fast != null && fast.next != null) {
            fast = fast.next.next;
            low = low.next;
        }

        return low;

    }
}
```

## 20220425：删除链表的倒数第N个结点

**题目描述**

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

**示例**

输入：

```
head = [1,2,3,4,5], n = 2
```

输出：

```
[1,2,3,5]
```

**思路分析**

需要创建一个虚拟头结点，规避掉一些空指针的问题。

**代码**

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {

        ListNode res = new ListNode(0), dum = res;
        res.next = head;

        ListNode low = dum, fast = dum;

        for (int i = 0; i < n; i++) {
            fast = fast.next;
        }

        while (fast.next != null) {
            fast = fast.next;
            low = low.next;
        }
        low.next = low.next.next;

        return res.next;

    }
}
```

## 20220426：无重复最长子串

**题目描述**

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。

**示例**

输入：

```
s = "abcabcbb"
```

输出：

```
3
```

**思路分析**

滑动窗口，注意left应该取到map.get(s.charAt(i)) + 1，

**代码**

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Map<Character, Integer> map = new HashMap<>();
        int left = 0;
        int max = 0;
        for (int i = 0; i < s.length(); i++) {

            if (map.containsKey(s.charAt(i))) {
                left = Math.max(left, map.get(s.charAt(i)) + 1);
            }

            map.put(s.charAt(i), i);
            max = Math.max(max, i - left + 1);

        }

        return max;
    }
}
```

## 20220426：字符串的排列

**题目描述**

给你两个字符串 s1 和 s2 ，写一个函数来判断 s2 是否包含 s1 的排列。如果是，返回 true ；否则，返回 false 。

换句话说，s1 的排列之一是 s2 的 子串 。

**示例**

输入：

```
s1 = "ab" s2 = "eidbaooo"
```

输出：

```
true
```

**思路分析**

用int[26]的数组去记录s1和s2的每个字符的个数，然后对s2的个数数组进行循环判断。

**代码**

```java
class Solution {
    public boolean checkInclusion(String s1, String s2) {
        if (s1.length() > s2.length()) {
            return false;
        }

        int[] arr1 = new int[26];
        int[] arr2 = new int[26];
        int n = s1.length();

        for (int i = 0; i < n; i++) {
            arr1[s1.charAt(i) - 'a']++;
            arr2[s2.charAt(i) - 'a']++;
        }

        if (Arrays.equals(arr1, arr2)) {
            return true;
        }

        for (int i = 0; i < s2.length() - n; i++) {
            arr2[s2.charAt(i) - 'a']--;
            arr2[s2.charAt(i + n) - 'a']++;
            if (Arrays.equals(arr1, arr2)) {
                return true;
            }
        }

        return false;

    }
}
```

## 20220427：图形渲染

**题目描述**

有一幅以 m x n 的二维整数数组表示的图画 image ，其中 image[i][j] 表示该图画的像素值大小。

你也被给予三个整数 sr ,  sc 和 newColor 。你应该从像素 image[sr][sc] 开始对图像进行 上色填充 。

为了完成 上色工作 ，从初始像素开始，记录初始坐标的 上下左右四个方向上 像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应 四个方向上 像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为 newColor 。

最后返回 经过上色渲染后的图像 。。

**示例**

输入：

```
image = [[1,1,1],[1,1,0],[1,0,1]]，sr = 1, sc = 1, newColor = 2
```

输出：

```
[[2,2,2],[2,2,0],[2,0,1]]
```

**思路分析**

依然是深度优先遍历。

**代码**

```java
class Solution {
    static int[][] images;
    static int color;
    static int m, n;
    static int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
    static boolean[][] visits;
    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {
        images = image;
        m = image.length;
        n = image[0].length;
        color = newColor;
        visits = new boolean[m][n];
        dfs2(sr, sc, images[sr][sc]);

        return images;
    }

    public static void dfs2(int row, int col, int value) {

        if (visits[row][col]) {
            return;
        }

        images[row][col] = color;
        visits[row][col] = true;

        for (int[] dir : dirs) {
            //遍历得到新坐标
            int newRow = row + dir[0];
            int newCol = col + dir[1];
            //上色
            if (newRow >= 0 && newCol >= 0 && newRow <= m - 1 && newCol <= n - 1 && images[newRow][newCol] == value) {
                dfs2(newRow, newCol, value);
            }
        }

    }  
}
```

## 20220427：岛屿的最大面积

**题目描述**

给你一个大小为 m x n 的二进制矩阵 grid 。

岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在 水平或者竖直的四个方向上 相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。

岛屿的面积是岛上值为 1 的单元格的数目。

计算并返回 grid 中最大的岛屿面积。如果没有岛屿，则返回面积为 0 

**示例**

输入：

```
grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]
```

输出：

```
6
```

**思路分析**

深度优先遍历，这里的遍历是有返回值的。

**代码**

```java
class Solution {
    static int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
    public int maxAreaOfIsland(int[][] grid) {

        int max = 0;
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                max = Math.max(max, dfs3(grid, i, j));
            }
        }

        return max;

    }

    public static int dfs3(int[][] grid, int row, int col) {
        //不是土地
        if (grid[row][col] != 1) {
            return 0;
        }
        //表示已经访问过
        grid[row][col] = 0;

        int res = 1;
        for (int[] dir : dirs) {

            int newRow = row + dir[0];
            int newCol = col + dir[1];
            if (newRow >= 0 && newCol >= 0 && newRow <= grid.length - 1 && newCol <= grid[0].length - 1) {
                res += dfs3(grid, newRow, newCol);
            }

        }

        return res;

    }
}
```

## 20220428：合并二叉树

**题目描述**

给你两棵二叉树： root1 和 root2 。

想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。

返回合并后的二叉树。

注意: 合并过程必须从两个树的根节点开始。

**示例**

输入：

```
root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]
```

输出：

```
[3,4,5,5,4,null,7]
```

**思路分析**

深度优先遍历

**代码**

```java
class Solution {
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
        if (root1 == null) {
            return root2;
        }
        if (root2 == null) {
            return root1;
        }

        TreeNode res = new TreeNode(root1.val + root2.val);
        res.left = mergeTrees(root1.left, root2.left);
        res.right = mergeTrees(root1.right, root2.right);

        return res;

    }
}
```

## 20220428：填充每个节点的下一个右侧节点指针

**题目描述**

给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：

struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}

填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。

初始状态下，所有 next 指针都被设置为 NULL。

**示例**

输入：

```
root = [1,2,3,4,5,6,7]
```

输出：

```
[1,#,2,3,#,4,5,6,7,#]
```

**思路分析**

层次遍历

**代码**

```java
class Solution {
    public Node connect(Node root) {
        if (root == null) {
            return root;
        }

        Queue<Node> queue = new LinkedList<>();
        queue.add(root);

        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                Node node = queue.poll();
                if (i < size - 1) {
                    node.next = queue.peek();
                }
                
                if (node.left != null) {
                    queue.add(node.left);
                }
                if (node.right != null) {
                    queue.add(node.right);
                }
            }
        }
        return root;
       
    }
}
```

## 20220429：01矩阵

**题目描述**

给定一个由 0 和 1 组成的矩阵 mat ，请输出一个大小相同的矩阵，其中每一个格子是 mat 中对应位置元素到最近的 0 的距离。

两个相邻元素间的距离为 1 。

**示例**

输入：

```
mat = [[0,0,0],[0,1,0],[0,0,0]]
```

输出：

```
[[0,0,0],[0,1,0],[0,0,0]]
```

**思路分析**

使用广度优先遍历

**代码**

```java
class Solution {
    static int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
    public int[][] updateMatrix(int[][] mat) {

        int m = mat.length;
        int n = mat[0].length;
        int[][] res = new int[m][n];
        boolean[][] judge = new boolean[m][n];
        Queue<int[]> queue = new LinkedList<>();

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                //添加
                if (mat[i][j] == 0) {
                    queue.offer(new int[]{i ,j});
                    judge[i][j] = true;
                }

            }
        }

        while (!queue.isEmpty()) {

            int[] num = queue.poll();
            int row = num[0], col = num[1];
            for (int[] dir : dirs) {
                int newRow = row + dir[0];
                int newCol = col + dir[1];
                if (newRow >= 0 && newRow <= m - 1 && newCol >= 0 && newCol <= n -1 && !judge[newRow][newCol]) {
                    res[newRow][newCol] = res[row][col] + 1;
                    queue.offer(new int[]{newRow, newCol});
                    judge[newRow][newCol] = true;
                }
            }
        }


        return res;

    }
}
```

## 20220429：腐烂的桔子

**题目描述**

在给定的 m x n 网格 grid 中，每个单元格可以有以下三个值之一：

    值 0 代表空单元格；
    值 1 代表新鲜橘子；
    值 2 代表腐烂的橘子。

每分钟，腐烂的橘子 周围 4 个方向上相邻 的新鲜橘子都会腐烂。

返回 直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1 。

**示例**

输入：

```
grid = [[2,1,1],[1,1,0],[0,1,1]]
```

输出：

```
4
```

**思路分析**

广度优先遍历，需要提前记录好桔子的数量，当好桔子数量为0时，退出遍历

**代码**

```java
class Solution {
    static int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
    public int orangesRotting(int[][] grid) {

        int m = grid.length, n = grid[0].length;
        boolean[][] judge = new boolean[m][n];
        Queue<int[]> queue = new LinkedList<>();
        //新鲜桔子的数量
        int count = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    count++;
                }
                if (grid[i][j] == 2) {
                    queue.offer(new int[]{i ,j});
                    judge[i][j] = true;
                }

            }
        }

        int res = 0;

        while (count > 0 && !queue.isEmpty()) {

            int size = queue.size();
            res++;
            for (int i = 0; i < size; i++) {
                int[] poll = queue.poll();
                int row = poll[0];
                int col = poll[1];


                for (int[] dir : dirs) {

                    int newRow = row + dir[0];
                    int newCol = col + dir[1];

                    if (newRow >= 0 && newRow <= m - 1 && newCol >= 0 && newCol <= n - 1 && !judge[newRow][newCol] && grid[newRow][newCol] != 0) {
                        grid[newRow][newCol] = 2;
                        count--;
                        queue.offer(new int[]{newRow, newCol});
                        judge[newRow][newCol] = true;
                    }

                }
            }


        }

        return count > 0 ? -1 : res;

    }
}
```

## 20220430：合并两个有序链表

**题目描述**

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

**示例**

输入：

```
l1 = [1,2,4], l2 = [1,3,4]
```

输出：

```
[1,1,2,3,4,4]
```

**思路分析**

无

**代码**

```java
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {

        if (list1 == null) {
            return list2;
        }
        if (list2 == null) {
            return list1;
        }

        ListNode res = new ListNode(0), dum = res;

        while (list1 != null && list2 != null) {

            if (list1.val < list2.val) {
                dum.next = list1;
                list1 = list1.next;
            } else {
                dum.next = list2;
                list2 = list2.next;
            }
            dum = dum.next;

        }

        dum.next = list1 == null ? list2 : list1;

        return res.next;

    }
}
```

## 20220430：反转链表

**题目描述**

给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

**示例**

输入：

```
head = [1,2,3,4,5]
```

输出：

```
[5,4,3,2,1]
```

**思路分析**

记录当前结点和pre结点即可，循环里再新建next结点

**代码**

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        
        ListNode pre = null;
        ListNode node = head;

        while (node != null) {

            ListNode next = node.next;
            node.next = pre;
            pre = node;
            node = next;
        }

        return pre;

    }
}
```

## 20220515：全排列

**题目描述**

给定两个整数 `n` 和 `k`，返回范围 `[1, n]` 中所有可能的 `k` 个数的组合。

你可以按 **任何顺序** 返回答案。

**示例**

输入：

```
n = 4, k = 2
```

输出：

```
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
```

**思路分析**



**代码**

```java
class Solution {
    static List<List<Integer>> res;
    static List<Integer> list;
    public List<List<Integer>> combine(int n, int k) {

        res = new ArrayList<>();
        list = new ArrayList<>();

        backtracing(1, n, k);

        return res;

    }

    public static void backtracing(int index, int n, int k) {
        if (list.size() == k) {
            res.add(new ArrayList<Integer>(list));
            return;
        }

        for (int i = index; i <= n; i++) {
            list.add(i);
            backtracing(i + 1, n, k);
            list.remove(list.size() - 1);
        }


    }
}
```

## 20220515：全排列

**题目描述**

给定一个不含重复数字的数组 `nums` ，返回其 *所有可能的全排列* 。你可以 **按任意顺序** 返回答案。

**示例**

输入：

```
nums = [1,2,3]
```

输出：

```
[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

**思路分析**



**代码**

```java
class Solution {
    static List<List<Integer>> res;
    static List<Integer> list;
    public List<List<Integer>> permute(int[] nums) {

        int n = nums.length;
        res = new ArrayList<>();
        list = new ArrayList<>();
        boolean[] used = new boolean[n];
        backtracing2(0, used, n, nums);

        return res;

    }

    public static void backtracing2(int index, boolean[] used, int n, int[] nums) {

        if (index == n) {
            res.add(new ArrayList<Integer>(list));
            return;
        }

        for (int i = 0; i < n; i++) {
            if (!used[i]) {
                list.add(nums[i]);
                used[i] = true;
                backtracing2(index + 1, used, n, nums);
                used[i] = false;
                list.remove(list.size() - 1);
            }
        }
        
    }
}
```

## 20220515：字母大小写全排列

**题目描述**

给定一个字符串 `s` ，通过将字符串 `s` 中的每个字母转变大小写，我们可以获得一个新的字符串。

返回 *所有可能得到的字符串集合* 。以 **任意顺序** 返回输出。

**示例**

输入：

```
s = "a1b2"
```

输出：

```
["a1b2", "a1B2", "A1b2", "A1B2"]
```

**思路分析**



**代码**

```java
class Solution {
    public static List<String> letterCasePermutation(String s) {

        List<String> res = new ArrayList<>();
        char[] arr = s.toCharArray();

        backtracing3(0, arr, res);

        return res;

    }

    public static void backtracing3(int index, char[] arr, List<String> res) {
        if (index == arr.length) {
            res.add(new String(arr));
            return;
        }

        backtracing3(index + 1, arr, res);
        if (Character.isLetter(arr[index])) {
            //转化大小写
            arr[index] ^= ' ';
            backtracing3(index + 1, arr, res);
        }

    }

}
```

## 20220516：爬楼梯

**题目描述**

假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**示例**

输入：

```
n = 3
```

输出：

```
3
```

**思路分析**



**代码**

```java
class Solution {
    public int climbStairs(int n) {

        if (n == 1) {
            return 1;
        }

        int[] dp = new int[n + 1];
        dp[1] = 1;
        dp[2] = 2;

        for (int i = 3; i < dp.length; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }

        return dp[n];

    }
}
```

## 20220516：打家劫舍

**题目描述**

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

**示例**

输入：

```
[1,2,3,1]
```

输出：

```
4
```

**思路分析**

`dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);`

**代码**

```java
class Solution {
    public int rob(int[] nums) {

        int n = nums.length;
        if (n == 1) {
            return nums[0];
        }

        int[] dp = new int[n];
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0], nums[1]);
        for (int i = 2; i < n; i++) {
            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);
        }


        return dp[n - 1];

    }
}
```

## 20220516：三角形最小路径和

**题目描述**

给定一个三角形 triangle ，找出自顶向下的最小路径和。

每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/triangle
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

**示例**

输入：

```
triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]
```

输出：

```
11
```

**思路分析**



**代码**

```java
class Solution {
    public int minimumTotal(List<List<Integer>> triangle) {
        int n = triangle.size();
        if (triangle.size() == 1) {
            return triangle.get(0).get(0);
        }

        for (int i = 1; i < n; i++) {
            List<Integer> preList = triangle.get(i - 1);
            List<Integer> curList = triangle.get(i);

            for (int j = 0; j < curList.size(); j++) {
                if (j == 0) {
                    curList.set(j, preList.get(j) + curList.get(j));
                } else if (j == curList.size() - 1) {
                    curList.set(j, preList.get(j - 1) + curList.get(j));
                } else {
                    int min = Math.min(preList.get(j - 1), preList.get(j));
                    curList.set(j, min + curList.get(j));
                }
            }
            triangle.set(i, curList);
        }

        int res = Integer.MAX_VALUE;
        for (Integer integer : triangle.get(triangle.size() - 1)) {
            res = Math.min(res, integer);
        }

        return res;

    }
}
```



















































## 20220516：

**题目描述**



**示例**

输入：

```

```

输出：

```

```

**思路分析**



**代码**

```java

```

