## 20220410：唯一摩尔斯密码词

**题目描述**

国际摩尔斯密码定义一种标准编码方式，将每个字母对应于一个由一系列点和短线组成的字符串， 比如:

    'a' 对应 ".-" ，
    'b' 对应 "-..." ，
    'c' 对应 "-.-." ，以此类推。

为了方便，所有 26 个英文字母的摩尔斯密码表如下：

```
[".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."]
```

给你一个字符串数组 words ，每个单词可以写成每个字母对应摩尔斯密码的组合。

    例如，"cab" 可以写成 "-.-..--..." ，(即 "-.-." + ".-" + "-..." 字符串的结合)。我们将这样一个连接过程称作 单词翻译 。

对 words 中所有单词进行单词翻译，返回不同 单词翻译 的数量。

**示例**

输入：

```
输入: words = ["gin", "zen", "gig", "msg"]
解释: 
各单词翻译如下:
"gin" -> "--...-."
"zen" -> "--...-."
"gig" -> "--...--."
"msg" -> "--...--."
```

输出：

```
2
```

**思路分析**

用hashset过滤唯一值，结果就是hashset的长度。

**代码**

```java
class Solution {
    public int uniqueMorseRepresentations(String[] words) {
        char[] zimu = "abcdefghijklmnopqrstuvwxyz".toCharArray();
        String[] mosi = {".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."};

        Map<Character, String> map = new HashMap<>();
        for (int i = 0; i < zimu.length; i++) {
            map.put(zimu[i], mosi[i]);
        }

        Set<String> set = new HashSet<>();

        for (int i = 0; i < words.length; i++) {
            StringBuilder sb = new StringBuilder();
            for (int j = 0; j < words[i].length(); j++) {
                sb.append(map.get(words[i].charAt(j)));
            }
            set.add(sb.toString());

        }
        return set.size();


    }
}
```

也可以不使用hashmap存储字母与摩尔斯字符的对应关系

```java
class Solution {
    public int uniqueMorseRepresentations(String[] words) {
        String[] mosi = {".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."};

        Set<String> set = new HashSet<>();

        for (int i = 0; i < words.length; i++) {
            StringBuilder sb = new StringBuilder();
            for (int j = 0; j < words[i].length(); j++) {
                sb.append(mosi[words[i].charAt(j) - 'a']);
            }
            set.add(sb.toString());

        }

        return set.size();


    }
}
```

## 20220410：罗马数字转整数

**题目描述**

罗马数字包含以下七种字符: `I`， `V`， `X`， `L`，`C`，`D` 和 `M`。

```
字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
```

例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：

    I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
    X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
    C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。

给定一个罗马数字，将其转换成整数。

**示例**

输入：

```
s = "MCMXCIV"
```

输出：

```
1994
```

**思路分析**

思路一：从后往前遍历罗马字符，当遇到当前字符比下一个字符小时，对这两个字符进行合并处理。

思路二：从前往后遍历罗马字符，当遇到当前字符比前个字符小时，sum加上，否则减去。

**代码**
思路一：

```java
class Solution {
    public int romanToInt(String s) {
        String[] luoma = {"I", "V", "X", "L", "C", "D", "M"};
        Map<String, Integer> index_map = new HashMap<>();
        for (int i = 0; i < luoma.length; i++) {
            index_map.put(luoma[i], i);
        }
        int[] shuzhi = {1, 5, 10, 50, 100, 500, 1000};

        Map<String, Integer> value_map = new HashMap<>();
        for (int i = 0; i < luoma.length; i++) {
            value_map.put(luoma[i], shuzhi[i]);
        }
        String[] array = s.split("");

        int res = 0;
        for (int i = array.length - 1; i > 0; i--) {
            //前一个字符串所对应的索引必须比当前的小，否则为-
            if (index_map.get(array[i]) <= index_map.get(array[i - 1])) {
                res += value_map.get(array[i]);
            } else {
                res += (value_map.get(array[i]) - value_map.get(array[i - 1]));
                i--;
                if (i == 0) {
                    return res;
                }
            }
        }
        res += value_map.get(array[0]);

        return res;

    }
}
```

思路二：

```java
class Solution {
    public int romanToInt(String s) {
        String[] luoma = {"I", "V", "X", "L", "C", "D", "M"};
        int[] shuzhi = {1, 5, 10, 50, 100, 500, 1000};

        Map<String, Integer> value_map = new HashMap<>();
        for (int i = 0; i < luoma.length; i++) {
            value_map.put(luoma[i], shuzhi[i]);
        }
        String[] array = s.split("");

        int res = 0, preNum = 0, num;


        for (int i = 0; i < array.length; i++) {
            num = value_map.get(array[i]);
            //正常情况
            if (preNum >= num) {
                res += preNum;
            } else {
                res -= preNum;
            }
            preNum = num;
        }
        res += preNum;

        return res;

    }
}
```

## 20220410：整数转罗马数字

**题目描述**

罗马数字包含以下七种字符: `I`， `V`， `X`， `L`，`C`，`D` 和 `M`。

```
字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
```

例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：

    I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
    X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
    C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。

给定一个整数，将其转换成罗马数字。

**示例**

输入：

```
s = 1994
```

输出：

```
"MCMXCIV"
```

**思路分析**

使用贪心算法，列出所有的数字可能，从大的开始减。

**代码**

```java
class Solution {
    public int romanToInt(String s) {
        public String intToRoman(int num) {
        int[] nums = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5 , 4, 1};
        String[] romans = {"M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"};
        Map<Integer, String> map = new HashMap<>();
        for (int i = 0; i < romans.length; i++) {
            map.put(nums[i], romans[i]);
        }

        StringBuilder sb = new StringBuilder();

        while (num != 0) {
            for (int i = 0; i < nums.length; i++) {
                if (num >= nums[i]) {
                    num -= nums[i];
                    sb.append(map.get(nums[i]));
                    break;
                }
            }
        }

        return sb.toString();
    }
}
```

## 20220411：统计各位数字都不同的数字个数

**题目描述**

给你一个整数 `n` ，统计并返回各位数字都不同的数字 `x` 的个数，其中 `0 <= x < 10n` 。

**示例**

输入：

```
n = 2
```

输出：

```
91
```

**思路分析**

使用动态规划，n=0时为1，n=1时为10，当n=2时，答案为n=1时的结果+{1,2,3,4,5,6,7,8,9}这九个数后面再补一位不重复的数，即10+9\*9=91。同样的n=3时，答案为n=2时的结果+9\*9*这81个数后面再补一位不重复的数，91+9\*9\*8=739

**代码**

```java
class Solution {
    public int countNumbersWithUniqueDigits(int n) {

        if (n == 0) {
            return 1;
        }
        if (n == 1) {
            return 10;
        }

        int res = 10, tmp = 9;
        for (int i = 2; i <= n; i++) {
            res += tmp * (10 - i + 1);
            tmp *= (10 - i + 1);
        }

        return res;

    }
}
```

## 20220411：整数反转

**题目描述**

给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。

如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。
假设环境不允许存储 64 位整数（有符号或无符号）。

**示例**

输入：

```
321
```

输出：

```
123
```

**思路分析**

递归构造反转后的数字

**代码**

```java
class Solution {
    public int reverse(int x) {
        int res = 0;
        while (x != 0) {
            if (res < Integer.MIN_VALUE / 10 || res > Integer.MAX_VALUE / 10) {
                return 0;
            }
            //得到个位
            int digit = x % 10;
            x /= 10;
            //递进
            res = res * 10 + digit;
        }
        // return x > 0 ? res : res * -1;
        return res;

    }
}
```

## 20220411：无重复字符的最长子串

**题目描述**

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。

**示例**

输入：

```
s = "abcabcbb"
```

输出：

```
3
```

**思路分析**

使用滑动窗口的思路

**代码**

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        if (s.length() == 0) {
            return 0;
        }

        Map<Character, Integer> map = new HashMap<>();

        char[] c = s.toCharArray();
        int max = 0;
        int left = 0;
        for (int i = 0; i < c.length; i++) {
            if (map.containsKey(c[i])) {
                left = Math.max(left, map.get(c[i]) + 1);
            }
            map.put(c[i],i);
            max = Math.max(max, i - left + 1);
        }
        return max;

    }
}
```

## 20220412：写字符串所需要的行数

**题目描述**

我们要把给定的字符串 S 从左到右写到每一行上，每一行的最大宽度为100个单位，如果我们在写某个字母的时候会使这行超过了100 个单位，那么我们应该把这个字母写到下一行。我们给定了一个数组 widths ，这个数组 widths[0] 代表 'a' 需要的单位， widths[1] 代表 'b' 需要的单位，...， widths[25] 代表 'z' 需要的单位。

现在回答两个问题：至少多少行能放下S，以及最后一行使用的宽度是多少个单位？将你的答案作为长度为2的整数列表返回。

**示例**

输入：

```
widths = [4,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10]
S = "bbbcccdddaaa"
```

输出：

```
[2, 4]
解释: 
除去字母'a'所有的字符都是相同的单位10，并且字符串 "bbbcccdddaa" 将会覆盖 9 * 10 + 2 * 4 = 98 个单位.
最后一个字母 'a' 将会被写到第二行，因为第一行只剩下2个单位了。
所以，这个答案是2行，第二行有4个单位宽度。
```

**思路分析**

无

**代码**

```java
class Solution {
    public int[] numberOfLines(int[] widths, String s) {

        String S = "abcdefghijklmnopqrstuvwxyz";
        Map<Character, Integer> map = new HashMap<>();
        for (int i = 0; i < 26; i++) {
            map.put(S.charAt(i), widths[i]);
        }

        char[] c = s.toCharArray();
        int line = 0, cur = 0;
        for (int i = 0; i < c.length; i++) {
            // 此时没超过100
            if (100 - cur >= map.get(c[i])) {
                cur += map.get(c[i]);
            } else {
                line++;
                cur = map.get(c[i]);
            }
        }

        return new int[]{line + 1, cur};

    }
}
```

## 20220412：两数之和

**题目描述**

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

**示例**

输入：

```
nums = [2,7,11,15], target = 9
```

输出：

```
[0,1]
```

**思路分析**

用Hashmap存储已经计算过的数

**代码**

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();

        for (int i = 0; i < nums.length; i++) {
            if (!map.containsKey(nums[i])) {
                map.put(target - nums[i], i);
            } else {
                return new int[]{map.get(nums[i]), i};
            }
        }

        return new int[2];

    }
}
```

## 20220412：正则字符串匹配

**题目描述**

给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。

    '.' 匹配任意单个字符
    '*' 匹配零个或多个前面的那一个元素

所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。

**示例**

输入：

```
s = "aa", p = "a"
```

输出：

```
false
```

**思路分析**

思路解析：https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/solution/zhu-xing-xiang-xi-jiang-jie-you-qian-ru-shen-by-je/

**代码**

```java
class Solution {
    public boolean isMatch(String s, String p) {
        int M = s.length();
        int N = p.length();
        boolean[][] dp = new boolean[M + 1][N + 1];

        for (int i = 0; i < dp.length; i++) {
            for (int j = 0; j < dp[0].length; j++) {

                //判断空正则和非空正则
                if (j == 0) {
                    dp[i][j] = i == 0;
                } else {
                    //判断p.charAt(j - 1)是否为'*'
                    if (p.charAt(j - 1) != '*') {
                        if (i >= 1 && (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.')) {
                            dp[i][j] = dp[i - 1][j - 1];
                        }
                    } else {
                        //不看*： 将*前面的字符省略
                        if (j >= 2) {
                            dp[i][j] |= dp[i][j - 2];
                        }
                        //看*
                        if (i >= 1 && j >= 2 && (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.')) {
                            dp[i][j] |= dp[i-1][j];
                        }
                    }
                }
            }
        }

        return dp[M][N];

    }
}
```

## 20220413：O(1)时间插入、删除和获取随机元素	

**题目描述**

实现RandomizedSet 类：

    RandomizedSet() 初始化 RandomizedSet 对象
    bool insert(int val) 当元素 val 不存在时，向集合中插入该项，并返回 true ；否则，返回 false 。
    bool remove(int val) 当元素 val 存在时，从集合中移除该项，并返回 true ；否则，返回 false 。
    int getRandom() 随机返回现有集合中的一项（测试用例保证调用此方法时集合中至少存在一个元素）。每个元素应该有 相同的概率 被返回。

你必须实现类的所有函数，并满足每个函数的 平均 时间复杂度为 O(1) 。

**示例**

输入：

```
["RandomizedSet", "insert", "remove", "insert", "getRandom", "remove", "insert", "getRandom"]
[[], [1], [2], [2], [], [1], [2], []]
```

输出：

```
[null, true, false, true, 2, true, false, 2]
```

**思路分析**

使用Hashmap+ArrayList来解决，将value,index存入map，当删除时，需要把list末尾的元素移到待删除的元素处。

**代码**

```java
class RandomizedSet {

    List<Integer> list;
    Map<Integer, Integer> map;
    Random random;

    public RandomizedSet() {

        list = new ArrayList<>();
        map = new HashMap<>();
        random = new Random();

    }
    
    public boolean insert(int val) {

        if (!map.containsKey(val)) {
            int index = list.size();
            map.put(val, index);
            list.add(val);
            return true;
        }
        return false;

    }
    
    public boolean remove(int val) {

        //需要把原列表最后一个数字移到删除数字的位置上，才能保证索引连接
        if (map.containsKey(val)) {
            //删除
            int index = map.get(val);
            int last_value = list.get(list.size() - 1);
            list.set(index, last_value);
            map.put(last_value, index);
            list.remove(list.size() - 1);
            map.remove(val);
            return true;
        }
        return false;

    }
    
    public int getRandom() {

        int number = random.nextInt(list.size());
        return list.get(number);

    }
}
```

## 20220413：两数相加

**题目描述**

给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

**示例**

输入：

```
l1 = [2,4,3], l2 = [5,6,4]
```

输出：

```
[7,0,8]
```

**思路分析**

循环相加，记录进位即可

**代码**

```java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {

        ListNode res = new ListNode(0), dum = res;

        int carry = 0, up = 0;
        while (l1 != null || l2 != null) {

            int n1 = l1 != null ? l1.val : 0;
            int n2 = l2 != null ? l2.val : 0;
            carry = (n1 + n2 + up) % 10;
            up = (n1 + n2 + up) / 10;
            dum.next = new ListNode(carry);
            dum = dum.next;

            if (l1 != null) {
                l1 = l1.next;
            }if (l2 != null) {
                l2 = l2.next;
            }
            
        }
        if (up==1){
            dum.next = new ListNode(1);
            dum = dum.next;

        }
        return res.next;

    }
}
```

## 20220413：寻找两位正序数组的中位数

**题目描述**

给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。

算法的时间复杂度应该为 O(log (m+n)) 

**示例**

输入：

```
nums1 = [1,3], nums2 = [2]
```

输出：

```
2
```

**思路分析**

合并数组做了，复杂度为n+m

**代码**

```java
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {

        int n=nums1.length, m=nums2.length;
        int len=n+m;
        int i=0,j=0,k=0;
        int[] tmp=new int[len/2+1];
        while(k<=len/2){
            if(i>=n) tmp[k++] = nums2[j++];
            else if(j>=m) tmp[k++] = nums1[i++];   
            else if(nums1[i]>nums2[j]) tmp[k++] = nums2[j++];
            else tmp[k++] = nums1[i++]; 
        }
        if(len%2==0){
            return (tmp[len/2]+tmp[len/2-1])/2.0;
        }else{
            return tmp[len/2];
        }

    }
}
```

## 20220414：最富有客户资产总量

**题目描述**

给你一个 m x n 的整数网格 accounts ，其中 accounts[i][j] 是第 i 位客户在第 j 家银行托管的资产数量。返回最富有客户所拥有的 资产总量 。

客户的 资产总量 就是他们在各家银行托管的资产数量之和。最富有客户就是 资产总量 最大的客户。

**示例**

输入：

```
accounts = [[1,2,3],[3,2,1]]
```

输出：

```
6
```

**思路分析**

无

**代码**

```java
class Solution {
    public int maximumWealth(int[][] accounts) {
        int max = 0;
        for (int i = 0; i < accounts.length; i++) {
            int account = 0;
            for (int j = 0; j < accounts[0].length; j++) {
                account += accounts[i][j];
            }
            max = Math.max(account, max);
        }

        return max;

    }
}
```

## 20220414：最长回文子串

**题目描述**

给你一个字符串 `s`，找到 `s` 中最长的回文子串。

**示例**

输入：

```
s = "babad"
```

输出：

```
"aba" 或 "bab" 
```

**思路分析**

使用中心扩散的思想，写一个中心扩散函数，传入左边扩散边界和右边扩散边界，然后对s进行循环即可。

**代码**

```java
class Solution {
    public String longestPalindrome(String s) {

        int max = 0, index = 0;
        for (int i = 0; i < s.length(); i++) {

            int single = judge(s, i, i);
            int both = 0;
            if(i+1<s.length()){
                both = judge(s, i, i + 1);
            }

            max = Math.max(max, Math.max(single, both));
            if (max == Math.max(single, both)) {
                index = i;
            }

        }

        return s.substring(index - (max - 1) / 2, index + max / 2 + 1);
    }

    public int judge(String s, int left, int right){
        while (left >= 0 && right <= s.length() - 1 && s.charAt(left) == s.charAt(right)) {
            left--;
            right++;
        }

        return right - left - 1;
    }
}
```

## 20220414：Z字形变化

**题目描述**

将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。

比如输入字符串为 "PAYPALISHIRING" 行数为 3 时，排列如下：

```
P   A   H   N
A P L S I I G
Y   I   R
```

之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如："PAHNAPLSIIGYIR"。

请你实现这个将字符串进行指定行数变换的函数：

```
string convert(string s, int numRows);
```

**示例**

输入：

```
s = "PAYPALISHIRING", numRows = 3
```

输出：

```
"PAHNAPLSIIGYIR"
```

**思路分析**

https://leetcode-cn.com/problems/zigzag-conversion/solution/zzi-xing-bian-huan-by-jyd/

**代码**

```java
class Solution {
    public String convert(String s, int numRows) {

        if (numRows == 1) return s;

        StringBuilder[] sbs = new StringBuilder[numRows];
        for (int i = 0; i < sbs.length; i++) {
            sbs[i] = new StringBuilder();
        }

        //当前行数
        int curRow = 0;
        //记录当前是++还是--
        boolean flag = true;
        for (int i = 0; i < s.length(); i++) {

            if (curRow == 0) {
                flag = true;
            } else if (curRow == numRows - 1) {
                flag = false;
            }
            sbs[curRow].append(s.charAt(i));
            curRow = flag ? curRow + 1 : curRow - 1;
        }

        StringBuilder res = new StringBuilder();
        for (StringBuilder sb : sbs) {
            res.append(sb.toString());
        }

        return res.toString();
        

    }
}
```

## 20220415：回文数

**题目描述**

给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。

回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

- 例如，121 是回文，而 123 不是。

**示例**

输入：

```
x = 121
```

输出：

```
true
```

**思路分析**

思路一：将数字变成数字列表，然后从中心扩散判断即可。

思路二：数学解法

**代码**

思路一：

```java
class Solution {
    public boolean isPalindrome(int x) {
        if (x < 0) {
            return false;
        }
        int i = x, count = 0;
        while (i != 0) {
            i /= 10;
            count++;
        }
        int[] nums = new int[count];
        for (int j = 0; j < nums.length; j++) {
            nums[j] = x % 10;
            x /= 10;
        }

        int left = nums.length % 2 == 0 ? nums.length / 2 - 1 : nums.length / 2;
        int right = nums.length / 2;

        while (left >= 0 && right <= nums.length - 1) {
            if (nums[left] != nums[right]) {
                return false;
            }
            left--;
            right++;
        }
        return true;

    }
}
```

思路二：

```java
class Solution {
    public boolean isPalindrome(int x) {
        if (x < 0) {
            return false;
        }

        int div = 1;
        while (x / div >= 10) {
            div *= 10;
        }

        while (x > 0) {

            int left = x / div;
            int right = x % 10;
            if (left != right) {
                return false;
            }
            x = (x % div) / 10;
            div /= 100;

        }

        return true;

    }
}
```

## 20220415：盛水最多的容器

**题目描述**

给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。

找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

返回容器可以储存的最大水量。

说明：你不能倾斜容器。

**示例**

输入：

```
[1,8,6,2,5,4,8,3,7]
```

输出：

```
49
```

**思路分析**

使用双指针，指针i为索引开始，指针j为索引结束，遍历列表。面积为(j - i) \* min(height[i]，height[j])，然后从小的一端往左或往右移。



**代码**

```java
class Solution {
    public int maxArea(int[] height) {
        if (height.length <= 1) {
            return 0;
        }

        int i = 0, j = height.length - 1;
        int maxArea = 0;
        while (i != j) {
            //(j - i)在前面
            if (height[i] > height[j]) {
                maxArea = Math.max(maxArea, (j - i) * height[j--]);
            } else {
                maxArea = Math.max(maxArea, (j - i) * height[i++]);
            }

        }

        return maxArea;


    }
}
```

## 20220415：公共最长前缀

**题目描述**

编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 `""`。

**示例**

输入：

```
strs = ["flower","flow","flight"]
```

输出：

```
"fl"
```

**思路分析**

使用计数法，循环遍历strs，当当前字符计数与strs.length相同时吗，说明当前字符为公共字符，否则直接返回。

**代码**

```java
class Solution {
    public String longestCommonPrefix(String[] strs) {
        int min = 1000000;
        for (int i = 0; i < strs.length; i++) {
            min = Math.min(min, strs[i].length());
        }

        StringBuilder res = new StringBuilder();
        String s = strs[0];
        for (int i = 0; i < min; i++) {
            int count = 0;
            for (String str : strs) {
                if (s.charAt(i) == str.charAt(i)) {
                    count++;
                }
            }
            if (count == strs.length) {
                res.append(s.charAt(i));
            } else {
                break;
            }
        }

        return res.toString();

    }
}
```

## 20220416：三数之和

**题目描述**

给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。

注意：答案中不可以包含重复的三元组。

**示例**

输入：

```
nums = [-1,0,1,2,-1,-4]
```

输出：

```
[[-1,-1,2],[-1,0,1]]
```

**思路分析**

使用双指针的思路，首先将nums排序，固定第一个k，取双指针i=k+1，j=nums.length-1。当nums[k]>0时，直接退出循环，当k>0且nums[k]=nums[k-1]时，会出现重复，退出当层循环。

然后再对sum进行比较，大于0时j--，小于0时i++，注意跳过重复的值。等于0时输出，再进行j--和i++。

**代码**

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {

        Arrays.sort(nums);
        List<List<Integer>> res = new ArrayList<>();

        for (int k = 0; k < nums.length - 2; k++) {
            //如果nums[i]>0，则后续的三数之和必定大于0
            if (nums[k] > 0) {
                break;
            }
            //如果nums[i] == nums[i - 1],则会重复
            if (k > 0 && nums[k] == nums[k - 1]) {
                continue;
            }
            //另外两个指针
            int i = k + 1;
            int j = nums.length - 1;
            while (i < j) {
                int sum = nums[i] + nums[j] + nums[k];

                if (sum < 0) {
                    //跳过所有重复的nums[i]
                    while (i < j && nums[i] == nums[++i]);
                } else if (sum > 0) {
                    //跳过所有重复的nums[j]
                    while (i < j && nums[j] == nums[--j]);
                } else {
                    res.add(new ArrayList<Integer>(Arrays.asList(nums[i], nums[j], nums[k])));
                    while (i < j && nums[i] == nums[++i]);
                    while (i < j && nums[j] == nums[--j]);
                }
            }

        }

        return res;
    }
}
```

## 20220416：

**题目描述**

给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。

返回这三个数的和。

假定每组输入只存在恰好一个解。

**示例**

输入：

```
nums = [-1,2,1,-4], target = 1
```

输出：

```
2
```

**思路分析**

和上一题类似，只不过这道题是sum与target比较

**代码**

```java
class Solution {
    public int threeSumClosest(int[] nums, int target) {

        Arrays.sort(nums);

        int res = nums[0] + nums[1] + nums[2]; 
        for (int k = 0; k < nums.length; k++) {

            int i = k + 1;
            int j = nums.length - 1;

            while (i < j) {
                int sum = nums[k] + nums[i] + nums[j];
                if (Math.abs(sum - target) <= Math.abs(res - target)) {
                    res = sum;
                }
                if (sum > target) {
                    j--;
                } else if (sum < target) {
                    i++;
                } else {
                    return sum;
                }
            }
        }
        return res;
    }
}
```

## 20220416：电话号码的组合

**题目描述**

给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

**示例**

输入：

```
digits = "23"
```

输出：

```
["ad","ae","af","bd","be","bf","cd","ce","cf"]
```

**思路分析**

运用回溯。主函数里面定义变量和使用index=0开始回溯。

**代码**

```java
class Solution {
    static List<String> res;
    static Map<Character, String> map;
    static StringBuilder sb;
    static char[] c;
    public List<String> letterCombinations(String digits) {

        if (digits.length() == 0) {
            return new ArrayList<>();
        }

        map = new HashMap<>(){{
            put('2',"abc");
            put('3',"def");
            put('4',"ghi");
            put('5',"jkl");
            put('6',"mno");
            put('7',"pqrs");
            put('8',"tuv");
            put('9',"wxyz");
        }};

        res = new LinkedList<>();
        sb = new StringBuilder();

        c = digits.toCharArray();

        backtracing(0);

        return res;

    }


    public static void backtracing(int index) {

        if (index == c.length) {
            res.add(sb.toString());
            return;
        }

        String s = map.get(c[index]);
        int count = map.get(c[index]).length();

        for (int i = 0; i < count; i++) {
            sb.append(s.charAt(i));
            backtracing(index + 1);
            sb.deleteCharAt(index);
        }

    }
}
```

## 20220417：最简单的单词

**题目描述**

给定一个段落 (paragraph) 和一个禁用单词列表 (banned)。返回出现次数最多，同时不在禁用列表中的单词。

题目保证至少有一个词不在禁用列表中，而且答案唯一。

禁用列表中的单词用小写字母表示，不含标点符号。段落中的单词不区分大小写。答案都是小写字母。

**示例**

输入：

```
paragraph = "Bob hit a ball, the hit BALL flew far after it was hit."
banned = ["hit"]
```

输出：

```
"ball"
```

**思路分析**

重点是搞清楚如何使用正则表达式

**代码**

```java
class Solution {
    public String mostCommonWord(String paragraph, String[] banned) {
        //W+匹配任意不是字母，数字，下划线 的字符
        paragraph = paragraph.replaceAll("\\W+", " ").toLowerCase();
        //s+匹配任意个空格
        String[] s = paragraph.split("\\s+");


        Map<String, Integer> map = new HashMap<>();
        for (int i = 0; i < s.length; i++) {
            if (map.containsKey(s[i])) {
                map.put(s[i], map.get(s[i]) + 1);
            } else {
                map.put(s[i], 1);
            }
        }

        for (int i = 0; i < banned.length; i++) {
            if (map.containsKey(banned[i])) {
                map.remove(banned[i]);
            }
        }

        int max = 0;
        String res = "";
        for (String s1 : map.keySet()) {
            if (map.get(s1) >= max) {
                max = map.get(s1);
                res = s1;
            }
        }
        
        return res;

    }
}
```

## 20220417：删除链表的倒数第n个结点

**题目描述**

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

**示例**

输入：

```
head = [1,2,3,4,5], n = 2
```

输出：

```
[1,2,3,5]
```

**思路分析**

双指针+虚拟头结点

**代码**

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dum = new ListNode(0);
        dum.next = head;
        ListNode low = dum, fast = dum;

        for (int k = 0; k < n; k++) {
            fast = fast.next;
        }

        while (fast.next != null) {
            fast = fast.next;
            low = low.next;
        }
        low.next = low.next != null ? low.next.next : null;

        return dum.next;

    }
}
```

## 20220417：四数之和

**题目描述**

给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：

- 0 <= a, b, c, d < n
- a、b、c 和 d 互不相同
- nums[a] + nums[b] + nums[c] + nums[d] == target

你可以按 任意顺序 返回答案 。

**示例**

输入：

```
nums = [1,0,-1,0,-2,2], target = 0
```

输出：

```
[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]
```

**思路分析**

与前面三数之和思路类似，注意遍历长度，退出当层循环和退出本次循环的条件即可。

**代码**

```java
class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {
        if (nums.length < 4) {
            return new ArrayList<>();
        }
        Arrays.sort(nums);
        List<List<Integer>> res = new ArrayList<>();

        for (int n = 0; n < nums.length - 3; n++) {
            //跳过重复
            if (n > 0 && nums[n] == nums[n - 1]) {
                continue;
            }
            //最小的四个数都大于target

            if ((long) nums[n] + nums[n + 1] + nums[n + 2] + nums[n + 3] > target) {
                break;
            }
            //最大的四个数都小于target
            if ((long) nums[n] + nums[nums.length - 3] + nums[nums.length - 2] + nums[nums.length - 1] < target) {
                continue;
            }

            for (int m = n + 1; m < nums.length - 2; m++) {
                //跳过重复
                if (m > n + 1 && nums[m] == nums[m - 1]) {
                    continue;
                }
                //最小的四个数都大于target
                if ((long) nums[n] + nums[m] + nums[m + 1] + nums[m + 2] > target) {
                    break;
                }
                //最大的四个数都小于target
                if ((long) nums[n] + nums[m] + nums[nums.length - 2] + nums[nums.length - 1] < target) {
                    continue;
                }

                int i = m + 1;
                int j = nums.length - 1;
                while (i < j) {
                    int sum = nums[n] + nums[m] + nums[i] + nums[j];
                    if (sum > target) {
                        while (i < j && nums[j] == nums[--j]);
                    } else if (sum < target) {
                        while (i < j && nums[i] == nums[++i]);
                    } else {
                        res.add(new ArrayList<Integer>(Arrays.asList(nums[n], nums[m], nums[i], nums[j])));
                        while (i < j && nums[j] == nums[--j]);
                        while (i < j && nums[i] == nums[++i]);
                    }
                }
            }
        }


        return res;

    }
}
```

## 20220418：字典序排数

**题目描述**

给你一个整数 `n` ，按字典序返回范围 `[1, n]` 内所有整数。

你必须设计一个时间复杂度为 `O(n)` 且使用 `O(1)` 额外空间的算法。

**示例**

输入：

```
n = 13
```

输出：

```
[1,10,11,12,13,2,3,4,5,6,7,8,9]
```

**思路分析**

- n的数字也就是res的长度
- 定义number=1，当number\*10<=n时，则说明下一个数字是number\*10。否则，number++。当下一个数字是number%10==9或number>=n时，需要将number/10。
- 注意while

**代码**

```java
class Solution {
    public List<Integer> lexicalOrder(int n) {

        List<Integer> res = new ArrayList<>();

        int number = 1;
        //n表示循环次数，也就是res的长度+
        for (int i = 0; i < n; i++) {

            res.add(number);
            if (number * 10 <= n) {
                number *= 10;
            } else {
                while (number % 10 == 9 || number >= n) {
                    number /= 10;
                }
                number++;
            }

        }

        return res;

    }
}
```

## 20220418：有效的括号

**题目描述**

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

有效字符串需满足：

    左括号必须用相同类型的右括号闭合。
    左括号必须以正确的顺序闭合。

**示例**

输入：

```
s = "()"
```

输出：

```
true
```

**思路分析**

使用模拟链表的方式。

**代码**

```java
class Solution {
    static Map<Character, Character> map = new HashMap<>(){{
        put('(',')');
        put('[',']');
        put('{','}');
        put('?','?');
    }};
    public boolean isValid(String s) {

        LinkedList<Character> list = new LinkedList<>(){{
            addLast('?');
        }};

        char[] cs = s.toCharArray();
        for (char c : cs) {
            if (map.containsKey(list.getLast()) && map.get(list.getLast()) == c) {
                list.removeLast();
            } else {
                list.addLast(c);
            }
        }


        return list.size() == 1;

    }
}
```

## 20220418：合并两个有序链表

**题目描述**

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

**示例**

输入：

```
l1 = [1,2,4], l2 = [1,3,4]
```

输出：

```
[1,1,2,3,4,4]
```

**思路分析**

无

**代码**

```java
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {

        if (list1 == null && list2 == null) {
            return null;
        }

        if (list1 == null || list2 == null) {
            return list1 == null ? list2 : list1;
        }

        ListNode res = new ListNode(0), dum = res;
        while (list1 != null && list2 != null) {
            if (list1.val < list2.val) {
                dum.next = list1;
                list1 = list1.next;
            } else {
                dum.next = list2;
                list2 = list2.next;
            }
            dum = dum.next;
        }

        dum.next = list1 == null ? list2 : list1;


        return res.next;

    }
}
```

## 20220419：字符的最短距离

**题目描述**

给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。

返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。

两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。

**示例**

输入：

```
s = "loveleetcode", c = "e"
```

输出：

```
[3,2,1,0,1,0,0,1,2,2,1,0]
```

**思路分析**

思路一：使用中心扩散的思路

思路二：遍历两次

**代码**

思路一：

```java
class Solution {
    public int[] shortestToChar(String s, char c) {

        int[] res = new int[s.length()];

        for (int i = 0; i < res.length; i++) {

            int left = i;
            int right = i;

            while (left >= 0 && s.charAt(left) != c) {
                left--;
            }
            while (right <= s.length() - 1 && s.charAt(right) != c) {
                right++;
            }
            if (left == -1) {
                res[i] = right - i;
            } else if (right == s.length()) {
                res[i] = i - left;
            } else {
                res[i] = Math.min(i - left, right - i);
            }

        }

        return res;

    }
}
```

思路二：

```java
class Solution {
    public int[] shortestToChar(String s, char c) {

        int n = s.length();
        int[] res = new int[n];

        int left_index = -1;
        for (int i = 0; i < n; i++) {
            if (s.charAt(i) == c) {
                left_index = i;
            }
            res[i] = left_index == -1 ? n : i - left_index;
        }
        int right_index = -1;
        for (int i = n - 1; i >= 0; i--) {
            if (s.charAt(i) == c) {
                right_index = i;
            }
            res[i] = Math.min(res[i], right_index == -1 ? n : right_index - i);
        }


        return res;

    }
}
```

## 20220419：括号生成

**题目描述**

数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。

**示例**

输入：

```
n=3
```

输出：

```
["((()))","(()())","(())()","()(())","()()()"]
```

**思路分析**

使用递归，注意停止条件是左边括号小于右边括号

**代码**

```java
class Solution {
    static List<String> res;
    static StringBuilder sb;
    public List<String> generateParenthesis(int n) {
        res = new LinkedList<>();
        sb = new StringBuilder();

        backtarcing(n, 0, 0);
        return res;

    }

    //i为左括号数， j为右括号数
    public static void backtarcing(int n, int i, int j) {
        if (i < j) {
            return;
        }
        if (i == n && j == n) {
            res.add(sb.toString());
        }
        if (i < n) {
            sb.append("(");
            backtarcing(n, i + 1, j);
            sb.deleteCharAt(sb.length() - 1);
        }
        if (j < n) {
            sb.append(")");
            backtarcing(n, i, j + 1);
            sb.deleteCharAt(sb.length() - 1);
        }


    }
}
```

## 20220419：两两交换链表中的节点

**题目描述**

给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。

**示例**

输入：

```
head = [1,2,3,4]
```

输出：

```
[2,1,4,3]
```

**思路分析**

官方题解：https://leetcode-cn.com/problems/swap-nodes-in-pairs/solution/liang-liang-jiao-huan-lian-biao-zhong-de-jie-di-91/

**代码**

```java
class Solution {
    public ListNode swapPairs(ListNode head) {

        ListNode dum = new ListNode(0);
        dum.next = head;
        ListNode node = dum;

        while (node.next != null && node.next.next != null) {
            ListNode node1 = node.next;
            ListNode node2 = node.next.next;
            node.next = node2;
            node1.next = node2.next;
            node2.next = node1;
            //注意这里变成了node1
            node = node1;
        }

        return dum.next;

    }
}
```

## 20220420：文件的最长绝对路径

**题目描述**

假设有一个同时存储文件和目录的文件系统。下图展示了文件系统的一个示例：

这里将 dir 作为根目录中的唯一目录。dir 包含两个子目录 subdir1 和 subdir2 。subdir1 包含文件 file1.ext 和子目录 subsubdir1；subdir2 包含子目录 subsubdir2，该子目录下包含文件 file2.ext 。

在文本格式中，如下所示(⟶表示制表符)：

```
dir
⟶ subdir1
⟶ ⟶ file1.ext
⟶ ⟶ subsubdir1
⟶ subdir2
⟶ ⟶ subsubdir2
⟶ ⟶ ⟶ file2.ext
```

如果是代码表示，上面的文件系统可以写为 "dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext" 。'\n' 和 '\t' 分别是换行符和制表符。

文件系统中的每个文件和文件夹都有一个唯一的 绝对路径 ，即必须打开才能到达文件/目录所在位置的目录顺序，所有路径用 '/' 连接。上面例子中，指向 file2.ext 的 绝对路径 是 "dir/subdir2/subsubdir2/file2.ext" 。每个目录名由字母、数字和/或空格组成，每个文件名遵循 name.extension 的格式，其中 name 和 extension由字母、数字和/或空格组成。

给定一个以上述格式表示文件系统的字符串 input ，返回文件系统中 指向 文件 的 最长绝对路径 的长度 。 如果系统中没有文件，返回 0。	

**示例**

输入：

```
input = "dir\n\tsubdir1\n\tsubdir2\n\t\tfile.ext"
```

输出：

```
20
```

**思路分析**

官方题解：https://leetcode-cn.com/problems/longest-absolute-file-path/solution/wen-jian-de-zui-chang-jue-dui-lu-jing-by-fi0r/

**代码**

```java
int n = input.length();

        Stack<Integer> stack = new Stack<>();
        //当前指针
        int pos = 0;
        int ans = 0;
        while (pos < n) {

            //检测文件深度
            int depth = 1;
            while (pos < n && input.charAt(pos) == '\t') {
                pos++;
                depth++;
            }

            //统计当前文件名长度
            boolean isFile = false;
            int len = 0;
            while (pos < n && input.charAt(pos) != '\n') {
                if (input.charAt(pos) == '.') {
                    isFile = true;
                }
                len++;
                pos++;
            }

            //跳过换行符
            pos++;
            while (stack.size() >= depth) {
                stack.pop();
            }
            if (!stack.isEmpty()) {
                len += stack.peek() + 1;
            }
            if (isFile) {
                ans = Math.max(ans, len);
            } else {
                stack.push(len);
            }

        }

        return ans;
```

## 20220420：删除有序数组中的重复项

**题目描述**

给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。

由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。

将最终结果插入 nums 的前 k 个位置后返回 k 。

不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。

**示例**

输入：

```
nums = [0,0,1,1,1,2,2,3,3,4]
```

输出：

```
5, nums = [0,1,2,3,4]
```

**思路分析**

使用双指针，i表示修改后数组的下标，j表示当前数组的下标，循环j。当nums[i]==nums[j]时，j++，注意判断j的临界点。直到nums[i]!=nums[j]时，让nums[++i]=nums[j]，进行对原数组的修改，然后j++进行下一个元素的判断。

**代码**

```java
class Solution {
    public int removeDuplicates(int[] nums) {

        int i = 0, j = 0;
        while (j < nums.length) {

            while (nums[i] == nums[j]) {
                if (j == nums.length - 1){
                    break;
                }
                j++;
            }
            if (nums[j] != nums[i]) {
                nums[++i] = nums[j];
            }
            j++;
        }
        
        
        return i + 1;

    }
}
```

## 20220420：移除元素

**题目描述**

给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

**示例**

输入：

```
nums = [3,2,2,3], val = 3
```

输出：

```
2, nums = [2,2]
```

**思路分析**

思维不要局限于不换，可以反其道而行之。同样是使用双指针，如果当nums[i]!=val时，我们将nums[j]设为nums[i]，同时j++

**代码**

```java
class Solution {
    public int removeElement(int[] nums, int val) {

        int j = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] != val) {
                nums[j] = nums[i];
                j++;
            }

        }

        return j;

    }
}
```

## 20220421：山羊拉丁文

**题目描述**

给你一个由若干单词组成的句子 sentence ，单词间由空格分隔。每个单词仅由大写和小写英文字母组成。

请你将句子转换为 “山羊拉丁文（Goat Latin）”（一种类似于 猪拉丁文 - Pig Latin 的虚构语言）。山羊拉丁文的规则如下：

    如果单词以元音开头（'a', 'e', 'i', 'o', 'u'），在单词后添加"ma"。
        例如，单词 "apple" 变为 "applema" 。
    如果单词以辅音字母开头（即，非元音字母），移除第一个字符并将它放到末尾，之后再添加"ma"。
        例如，单词 "goat" 变为 "oatgma" 。
    根据单词在句子中的索引，在单词最后添加与索引相同数量的字母'a'，索引从 1 开始。
        例如，在第一个单词后添加 "a" ，在第二个单词后添加 "aa" ，以此类推。

返回将 sentence 转换为山羊拉丁文后的句子。

**示例**

输入：

```
sentence = "The quick brown fox jumped over the lazy dog"
```

输出：

```
"heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa"
```

**思路分析**

无

**代码**

```java
class Solution {
    public String toGoatLatin(String sentence) {
        if (sentence.length() == 0) {
            return sentence;
        }
        String[] s = sentence.split(" ");
        StringBuilder res = new StringBuilder();
        List<Character> list = new ArrayList(){{
            for (char c : "aeiouAEIOU".toCharArray()) {
                add(c);
            }
        }};

        for (int i = 0; i < s.length; i++) {
            //元音字母开头
            if (list.contains(s[i].charAt(0))) {
                res.append(s[i] + "ma");
            } else {
                res.append(s[i].substring(1) + s[i].charAt(0) +"ma");
            }
            for (int j = 0; j < i + 1; j++) {
                res.append("a");
            }
            if (i != s.length - 1) {
                res.append(" ");
            }
        }


        return res.toString();

    }
}
```

## 20220421：实现strStr()

**题目描述**

实现 strStr() 函数。

给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。

 

说明：

当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。

对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。

**示例**

输入：

```
haystack = "hello", needle = "ll"
```

输出：

```
2
```

**思路分析**

KMP思路

**代码**

```java
class Solution {
    public int strStr(String haystack, String needle) {

        int m = haystack.length(), n = needle.length();
        if (n == 0) {
            return 0;
        }
        int[][] dp = kmp(needle);
        int j = 0;
        for (int i = 0; i < m; i++) {
            j = dp[j][haystack.charAt(i)];
            if (j == n) {
                return i - n + 1;
            }
        }

        return -1;

    }

    public static int[][] kmp(String needle) {

        int n = needle.length();
        int[][] dp = new int[n][256];
        dp[0][needle.charAt(0)] = 1;
        int X = 0;
        for (int j = 1; j < n; j++) {
            for (int c = 0; c < 256; c++) {
                if (needle.charAt(j) == c) {
                    dp[j][c] = j + 1;
                } else {
                    dp[j][c] = dp[X][c];
                }
            }
            X = dp[X][needle.charAt(j)];
        }

        return dp;


    }
}
```

## 20220421：搜索插入位置

**题目描述**

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

请必须使用时间复杂度为 O(log n) 的算法。

**示例**

输入：

```
nums = [1,3,5,6], target = 5
```

输出：

```
2
```

**思路分析**

二分查找

**代码**

```java
class Solution {
    public int searchInsert(int[] nums, int target) {

        int i = 0, j = nums.length - 1;
        while (i <= j) {
            int mid = i + (j - i) / 2;
            if (nums[mid] > target) {
                j = mid - 1;
            } else if (nums[mid] < target) {
                i = mid + 1;
            } else {
                return mid;
            }
        }

        return i;

    }
}
```

## 20220422：旋转函数

**题目描述**

给定一个长度为 n 的整数数组 nums 。

假设 arrk 是数组 nums 顺时针旋转 k 个位置后的数组，我们定义 nums 的 旋转函数  F 为：

    F(k) = 0 * arrk[0] + 1 * arrk[1] + ... + (n - 1) * arrk[n - 1]

返回 F(0), F(1), ..., F(n-1)中的最大值 。

生成的测试用例让答案符合 32 位 整数。

**示例**

输入：

```
nums = [4,3,2,6]
```

输出：

```
26
```

**思路分析**

思路一：暴力，会超时

思路二：![image-20220422152124582](D:%5CApplication%5CTypora%5Cimage%5Cimage-20220422152124582.png)

**代码**

思路一：

```java
class Solution {
    public int maxRotateFunction(int[] nums) {
        int max = Integer.MIN_VALUE;
        //F(i)
        for (int i = 0; i < nums.length; i++) {

            int tmp = 0;
            int j = 0;
            for (int k = nums.length - i; k < nums.length; k++) {
                tmp += j++ * nums[k];
            }
            for (int k = 0; k < nums.length - i; k++) {
                tmp += j++ * nums[k];
            }
            max = Math.max(max, tmp);

        }


        return max;

    }
}
```

思路二：

```java
class Solution {
    public int maxRotateFunction(int[] nums) {
        int n = nums.length, numSum = 0;
        int f0 = 0;
        for (int i = 0; i < nums.length; i++) {
            f0 += i * nums[i];
            numSum += nums[i];
        }
        int max = f0;
        int cur = 0, prev = f0;
        for (int i = 1; i < n; i++) {
            cur = prev + numSum - n * nums[n - i];
            max = Math.max(max, cur);
            prev = cur;
        }

        return max;

    }
}
```

## 20220422：外观数列

**题目描述**

给定一个正整数 n ，输出外观数列的第 n 项。

「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。

你可以将其视作是由递归公式定义的数字字符串序列：

    countAndSay(1) = "1"
    countAndSay(n) 是对 countAndSay(n-1) 的描述，然后转换成另一个数字字符串。

前五项如下：

```
1 
11
21
1 
1211
111221
第一项是数字 1 
描述前一项，这个数是 1 即 “ 一 个 1 ”，记作 "11"
描述前一项，这个数是 11 即 “ 二 个 1 ” ，记作 "21"
描述前一项，这个数是 21 即 “ 一 个 2 + 一 个 1 ” ，记作 "1211"
描述前一项，这个数是 1211 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 "111221"
```

要 描述 一个数字字符串，首先要将字符串分割为 最小 数量的组，每个组都由连续的最多 相同字符 组成。然后对于每个组，先描述字符的数量，然后描述字符，形成一个描述组。要将描述转换为数字字符串，先将每组中的字符数量用数字替换，再将所有描述组连接起来。

**示例**

输入：

```
n = 4
```

输出：

```
“1211”
```

**思路分析**

循环迭代即可

**代码**

```java
class Solution {
    public String countAndSay(int n) {
        if (n == 1) {
            return "1";
        }

        String prev = "1";
        for (int i = 2; i <= n; i++) {
            StringBuilder cur = new StringBuilder();

            int start = 0;
            int index = 0;
            while (index < prev.length()) {
                int count = 0;
                while (index < prev.length() && prev.charAt(start) == prev.charAt(index)) {
                    count++;
                    index++;
                }
                cur.append(count + "");
                cur.append(prev.charAt(start));
                start = index;
            }
            prev = cur.toString();

        }

        return prev;

    }
}
```

## 20220424：二进制间距

**题目描述**

给定一个正整数 n，找到并返回 n 的二进制表示中两个 相邻 1 之间的 最长距离 。如果不存在两个相邻的 1，返回 0 。

如果只有 0 将两个 1 分隔开（可能不存在 0 ），则认为这两个 1 彼此 相邻 。两个 1 之间的距离是它们的二进制表示中位置的绝对差。例如，"1001" 中的两个 1 的距离为 3 。

**示例**

输入：

```
n = 22
```

输出：

```
2
```

**思路分析**

位运算

**代码**

```java
class Solution {
    public int binaryGap(int n) {

        int res = 0;
        int index = 0;
        int last = -1;
        while (n != 0) {
            if ((n & 1) == 1) {
                if (last != -1) {
                    res = Math.max(res, index - last);
                }
                last = index;
            }
            index++;
            n >>= 1;

        }

        return res;

    }
}
```

## 20220425：随机数索引

**题目描述**

给定一个可能含有重复元素的整数数组，要求随机输出给定的数字的索引。 您可以假设给定的数字一定存在于数组中。

注意：
数组大小可能非常大。 使用太多额外空间的解决方案将不会通过测试。

**示例**

输入：

```
int[] nums = new int[] {1,2,3,3,3};
Solution solution = new Solution(nums);
solution.pick(3);
```

输出：

```
2,3,4中的一个
```

**思路分析**

思路一：使用HashMap将所有的值与其对对应的索引列表存储起来。

思路二：蓄水池抽水问题。遍历nums，当我们第 i次遇到值为target 的元素时，随机选择区间 [0,i)内的一个整数，如果其等于 0，则将返回值置为该元素的下标，否则返回值不变。

**代码**

思路一：

```java
class Solution {

    Map<Integer, List<Integer>> map;
    Random random;
    public Solution(int[] nums) {
        map = new HashMap<>();
        random = new Random();
        for (int i = 0; i < nums.length; i++) {
            //key已存在就不做替换，不存在key则新增
            map.putIfAbsent(nums[i],new ArrayList<Integer>());
            map.get(nums[i]).add(i);
        }

    }

    public int pick(int target) {
        List<Integer> list = map.get(target);
        return list.get(random.nextInt(list.size()));

    }

}
```

思路二：

```java
class Solution {

    int[] nums;
    Random random;

    public Solution(int[] nums) {
        this.nums = nums;
        this.random = new Random();
    }
    
    public int pick(int target) {
        int count = 0;
        int index = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] == target) {
                count++;
                if (random.nextInt(count) == 0) {
                    index = i;
                }
            }
        }
        return index;
    }
}
```

## 20220426：三维形体投影面积

**题目描述**

在 n x n 的网格 grid 中，我们放置了一些与 x，y，z 三轴对齐的 1 x 1 x 1 立方体。

每个值 v = grid[i][j] 表示 v 个正方体叠放在单元格 (i, j) 上。

现在，我们查看这些立方体在 xy 、yz 和 zx 平面上的投影。

投影 就像影子，将 三维 形体映射到一个 二维 平面上。从顶部、前面和侧面看立方体时，我们会看到“影子”。

返回 所有三个投影的总面积 。

**示例**

输入：

```
[[1,2],[3,4]]
```

输出：

```
17
```

**思路分析**

https://leetcode-cn.com/problems/projection-area-of-3d-shapes/solution/san-wei-xing-ti-tou-ying-mian-ji-by-leet-d66y/

**代码**

```java
class Solution {
    public int projectionArea(int[][] grid) {

        int xArea = 0;
        int yArea = 0;
        int zArea = 0;

        for (int i = 0; i < grid.length; i++) {
            int xHeight = 0;
            int yHeight = 0;
            for (int j = 0; j < grid[0].length; j++) {
                zArea += grid[i][j] > 0 ? 1 : 0;
                yHeight = Math.max(yHeight, grid[i][j]);
                xHeight = Math.max(xHeight, grid[j][i]);
            }
            xArea += xHeight;
            yArea += yHeight;
        }
        
        return xArea + yArea + zArea;

    }
}
```

## 20220427：太平洋大西洋水流问题

**题目描述**

有一个 m × n 的矩形岛屿，与 太平洋 和 大西洋 相邻。 “太平洋” 处于大陆的左边界和上边界，而 “大西洋” 处于大陆的右边界和下边界。

这个岛被分割成一个由若干方形单元格组成的网格。给定一个 m x n 的整数矩阵 heights ， heights[r][c] 表示坐标 (r, c) 上单元格 高于海平面的高度 。

岛上雨水较多，如果相邻单元格的高度 小于或等于 当前单元格的高度，雨水可以直接向北、南、东、西流向相邻单元格。水可以从海洋附近的任何单元格流入海洋。

返回 网格坐标 result 的 2D列表 ，其中 result[i] = [ri, ci] 表示雨水可以从单元格 (ri, ci) 流向 太平洋和大西洋 。

**示例**

输入：

```
heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]
```

输出：

```
[[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]
```

**思路分析**

深度优先遍历。

**代码**

```java
class Solution {
    static int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
    static int[][] height;
    static int m, n;
    public List<List<Integer>> pacificAtlantic(int[][] heights) {
        height = heights;
        m = heights.length;
        n = heights[0].length;

        boolean[][] pacific = new boolean[m][n];
        boolean[][] atlantic = new boolean[m][n];
        
        //从边界开始遍历
        //搜索Pacific的左边界
        for (int i = 0; i < m; i++) {
            dfs(i, 0, pacific);
        }
        //搜索Pacific的上边界
        for (int j = 1; j < n; j++) {
            dfs(0, j, pacific);
        }
        //搜索Atlantic的右边界
        for (int i = 0; i < m; i++) {
            dfs(i, n - 1, atlantic);
        }
        //搜索Atlantic的下边界
        for (int j = 0; j < n; j++) {
            dfs(m - 1, j, atlantic);
        }

        //找重复的元素
        List<List<Integer>> res = new ArrayList<>();

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (pacific[i][j] && atlantic[i][j]) {
                    res.add(Arrays.asList(i,j));
                }
            }
        }

        return res;

    }

    public static void dfs(int row, int col, boolean[][] ocean) {

        if (ocean[row][col]) {
            return;
        }

        ocean[row][col] = true;

        //向四周扩散
        for (int[] dir : dirs) {

            int newRow = row + dir[0];
            int newCol = col + dir[1];
            if (newRow >= 0 && newCol >= 0 && newRow <= m - 1 && newCol <= n - 1 && height[newRow][newCol] >= height[row][col]) {
                dfs(newRow, newCol, ocean);
            }
        }
    }
}
```

## 20220428：按奇偶排序数组

**题目描述**

给你一个整数数组 `nums`，将 `nums` 中的的所有偶数元素移动到数组的前面，后跟所有奇数元素。

返回满足此条件的 **任一数组** 作为答案。

**示例**

输入：

```
nums = [3,1,2,4]
```

输出：

```
[2,4,3,1]
```

**思路分析**

使用快速排序思路

**代码**

```java
class Solution {
    public int[] sortArrayByParity(int[] nums) {

        int i = 0, j = nums.length - 1;
        while (i < j) {
            while (i < j && nums[j] % 2 != 0) {
                j--;
            }
            while (i < j && nums[i] % 2 == 0) {
                i++;
            }
            if (i < j) {
                int tmp = nums[i];
                nums[i] = nums[j];
                nums[j] = tmp;
            }
        }

        return nums;

    }
}
```

## 20220429：建立四叉树

**题目描述**

给你一个 n * n 矩阵 grid ，矩阵由若干 0 和 1 组成。请你用四叉树表示该矩阵 grid 。

你需要返回能表示矩阵的 四叉树 的根结点。

注意，当 isLeaf 为 False 时，你可以把 True 或者 False 赋值给节点，两种值都会被判题机制 接受 。

四叉树数据结构中，每个内部节点只有四个子节点。此外，每个节点都有两个属性：

    val：储存叶子结点所代表的区域的值。1 对应 True，0 对应 False；
    isLeaf: 当这个节点是一个叶子结点时为 True，如果它有 4 个子节点则为 False 



**示例**

输入：

```
grid = [[0,1],[1,0]]
```

输出：

```
[[0,1],[1,0],[1,1],[1,1],[1,0]]
```

**思路分析**

https://leetcode-cn.com/problems/construct-quad-tree/solution/jian-li-si-cha-shu-by-leetcode-solution-gcru/

**代码**

```java
class Solution {
    public Node construct(int[][] grid) {
        return dfs(grid, 0, 0, grid.length, grid.length);
        
    }
    public Node dfs(int[][] grid, int r0, int c0, int r1, int c1) {
        boolean same = true;
        for (int i = r0; i < r1; ++i) {
            for (int j = c0; j < c1; ++j) {
                if (grid[i][j] != grid[r0][c0]) {
                    same = false;
                    break;
                }
            }
            if (!same) {
                break;
            }
        }

        if (same) {
            return new Node(grid[r0][c0] == 1, true);
        }

        Node ret = new Node(
            true,
            false,
            dfs(grid, r0, c0, (r0 + r1) / 2, (c0 + c1) / 2),
            dfs(grid, r0, (c0 + c1) / 2, (r0 + r1) / 2, c1),
            dfs(grid, (r0 + r1) / 2, c0, r1, (c0 + c1) / 2),
            dfs(grid, (r0 + r1) / 2, (c0 + c1) / 2, r1, c1)
        );
        return ret;
    }
}
```

## 20220430：最小差值I

**题目描述**

给你一个整数数组 nums，和一个整数 k 。

在一个操作中，您可以选择 0 <= i < nums.length 的任何索引 i 。将 nums[i] 改为 nums[i] + x ，其中 x 是一个范围为 [-k, k] 的整数。对于每个索引 i ，最多 只能 应用 一次 此操作。

nums 的 分数 是 nums 中最大和最小元素的差值。 

在对  nums 中的每个索引最多应用一次上述操作后，返回 nums 的最低 分数 。

**示例**

输入：

```
nums = [1,3,6], k = 3
```

输出：

```
0
```

**思路分析**

思考问题，如果当nums的长度为1或max-min小于2k时，返回0，否则，返回max-min-2k

**代码**

```java
class Solution {
    public int smallestRangeI(int[] nums, int k) {

        if (nums.length == 1) {
            return 0;
        }

        int min = Integer.MAX_VALUE;
        int max = Integer.MIN_VALUE;

        for (int num : nums) {
            min = Math.min(min, num);
            max = Math.max(max, num);
        }
        
        
        return max - min > 2 * k ? max - min - 2 * k : 0;

    }
}
```

```java
//写法二
class Solution {
    public int smallestRangeI(int[] nums, int k) {

        int max = Arrays.stream(nums).max().getAsInt();
        int min = Arrays.stream(nums).min().getAsInt();

        return max - min >= 2 * k ? max - min - 2 * k : 0;
    }
}
```

## 20220501：两棵二叉搜索树中的所有元素

**题目描述**

给你 `root1` 和 `root2` 这两棵二叉搜索树。请你返回一个列表，其中包含 **两棵树** 中的所有整数并按 **升序** 排序。.

**示例**

输入：

```
root1 = [2,1,4], root2 = [1,0,3]
```

输出：

```
[0,1,1,2,3,4]
```

**思路分析**

首先用中序遍历将两个树分别整理的排序好的List，然后排序

**代码**

```java
class Solution {
    public List<Integer> getAllElements(TreeNode root1, TreeNode root2) {

        List<Integer> res1 = inorder(root1);
        List<Integer> res2 = inorder(root2);
        List<Integer> res = new ArrayList<>();

        int i = 0, j = 0;

        while (i < res1.size() && j < res2.size()) {

            int num1 = res1.get(i);
            int num2 = res2.get(j);

            if (num1 < num2) {
                res.add(num1);
                i++;
            } else {
                res.add(num2);
                j++;
            }
        }

        res.addAll(i == res1.size() ? res2.subList(j, res2.size()) : res1.subList(i, res1.size()));

        return res;

    }

    public static List<Integer> inorder(TreeNode root) {

        Stack<TreeNode> stack = new Stack<>();
        TreeNode node = root;
        List<Integer> res = new ArrayList<>();

        while (node != null || !stack.isEmpty()) {
            if (node != null) {
                stack.push(node);
                node = node.left;
            } else {
                TreeNode tmp = stack.pop();
                res.add(tmp.val);
                node = tmp.right;
            }
        }
        return res;

    }

}
```

## 20220504：找出游戏的获胜者

**题目描述**

共有 n 名小伙伴一起做游戏。小伙伴们围成一圈，按 顺时针顺序 从 1 到 n 编号。确切地说，从第 i 名小伙伴顺时针移动一位会到达第 (i+1) 名小伙伴的位置，其中 1 <= i < n ，从第 n 名小伙伴顺时针移动一位会回到第 1 名小伙伴的位置。

游戏遵循如下规则：

    从第 1 名小伙伴所在位置 开始 。
    沿着顺时针方向数 k 名小伙伴，计数时需要 包含 起始时的那位小伙伴。逐个绕圈进行计数，一些小伙伴可能会被数过不止一次。
    你数到的最后一名小伙伴需要离开圈子，并视作输掉游戏。
    如果圈子中仍然有不止一名小伙伴，从刚刚输掉的小伙伴的 顺时针下一位 小伙伴 开始，回到步骤 2 继续执行。
    否则，圈子中最后一名小伙伴赢得游戏。

给你参与游戏的小伙伴总数 n ，和一个整数 k ，返回游戏的获胜者。

**示例**

输入：

```
n = 5, k = 2
```

输出：

```
3
```

**思路分析**

思路一：用队列来模拟

思路二：约瑟夫环问题

**代码**

思路一：

```java
class Solution {
    public int findTheWinner(int n, int k) {
        Queue<Integer> queue = new LinkedList<>();

        for (int i = 1; i <= n; i++) {
            queue.offer(i);
        }
        
        while (queue.size() > 1) {
            for (int i = 0; i < k - 1; i++) {
                queue.offer(queue.poll());
            }
            queue.poll();
        }

        return queue.poll();

    }
}
```

思路二：

```java
class Solution {
    public int findTheWinner(int n, int k) {
        int pos = 0;
        for (int i = 2; i < n + 1; ++i) {
            pos = (pos + k) % i;
        }
        return pos + 1;
    }
}
```

## 20220505：乘积小于k的子数组

**题目描述**

给你一个整数数组 `nums` 和一个整数 `k` ，请你返回子数组内所有元素的乘积严格小于 `k` 的连续子数组的数目。

**示例**

输入：

```
nums = [10,5,2,6], k = 100
```

输出：

```
8
```

**思路分析**

https://leetcode-cn.com/problems/subarray-product-less-than-k/solution/cheng-ji-xiao-yu-k-de-zi-shu-zu-by-leetc-92wl/

**代码**

```java
class Solution {
    public int numSubarrayProductLessThanK(int[] nums, int k) {

        int res = 1;
        int left = 0, right = 0;
        int count = 0;
        while (right <= nums.length - 1) {
            res *= nums[right++];

            while (left < right && res >= k) {
                res /= nums[left++];
            }

            count += right - left;


        }


        return count;

    }
}
```

## 20220506：最近的请求次数

**题目描述**

写一个 RecentCounter 类来计算特定时间范围内最近的请求。

请你实现 RecentCounter 类：

    RecentCounter() 初始化计数器，请求数为 0 。
    int ping(int t) 在时间 t 添加一个新请求，其中 t 表示以毫秒为单位的某个时间，并返回过去 3000 毫秒内发生的所有请求数（包括新请求）。确切地说，返回在 [t-3000, t] 内发生的请求数。

保证 每次对 ping 的调用都使用比之前更大的 t 值。

**示例**

输入：

```
["RecentCounter", "ping", "ping", "ping", "ping"]
[[], [1], [100], [3001], [3002]]
```

输出：

```
[null, 1, 2, 3, 3]
```

**思路分析**

思路一：用hashmap记录

思路二：单调队列

**代码**

思路一：

```java
class RecentCounter {

    Map<Integer, Integer> map;
    public RecentCounter() {
        map = new HashMap<>();
    }
    
    public int ping(int t) {
        int len = map.size();
        map.put(len, t);

        int res = 0;
        for (int i = len; i >=0 && map.get(len) - map.get(i) <= 3000; i--) {
            res++;
        }

        return res;
    }
}
```

思路二：

```java
class RecentCounter {

    Deque<Integer> queue;
    public RecentCounter() {
        queue = new LinkedList<>();
    }
    
    public int ping(int t) {
        queue.offerLast(t);
        while (!queue.isEmpty() && t - queue.peekFirst() > 3000) {
            queue.pollFirst();
        }

        return queue.size();
    }
}
```

































## 20220506：

**题目描述**



**示例**

输入：

```

```

输出：

```

```

**思路分析**



**代码**

```java

```

























