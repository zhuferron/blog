

- Java栈、本地方法栈和程序计数器一定不会存在GC机制，GC机制在方法区和堆，而JVM调优基本都是在堆和方法区调优，大部分在堆里面调优。

- **类加载器**，new了一个对象后引用放在栈里面，实例放在堆里面，

  - 类加载器首先进行加载和初始化，变成一个Class，该Class全局唯一，单例模式
  - 单例模式：创建的Class全局唯一，因为类是模板，是抽象的，对象是具体的，根据模板创建的
  - Class经过new(实例化)，可以实例化很多不同的对象
  - 反实例化：由实例对象得到Class：`getClass()`
  - 创建后的对象实例存储在堆里面，对象引用放在方法区中。
  - - 类加载器分类：
      - 虚拟机自带的加载器
      - 启动类（根）加载器
      - 扩展类加载器
      - 应用程序加载器
  - 返回类加载器：`getClassLoader()` —>应用程序加载器
  - 返回类加载器的父类：`getClassLoader().getParent()` —>拓展类加载器

  

- **双亲委派机制**：为了保证安全
  
  - 应用程序加载器—>拓展类加载器—>启动类加载器(rt.jar)
  - 每次加载一个类，都会找到最上面的启动类加载类(Boostrap)，如果找不到，才会去拓展类加载器找，如果还找不到再去应用程序加载器中寻找。

- 沙箱安全机制：
  - 字节码校验器：确保Java文件遵循Java语言规范
  - 类装载器：
    - 防止恶意代码去干涉善意的代码；双亲委派机制
    - 守护了被信任的类库边界
    - 它将代码归入保护域，确定了代码可以进行哪些操作

**重点：**Native、PC寄存器、方法区(static、final、Class、**常量池**（不同版本的常量池在不同的位置）)：

- 凡是带了`native`的关键字，说明java的作用范围达不到了，它会去调用底层C语言写的库，该方法被调用后会进入本地方法栈，此时本地方法栈会通过JNI(java本地方法接口)去调用本地方法库，JNI做的优点就是**拓展了java的使用，融合不同的编程语言为java使用，最初就是为了调用c和c++。**它会在内存中专门开辟一块标记区域：本地方法栈，它的目的是为了登记本地方法。
- PC寄存器也就是程序计数器，每个线程都是一个程序计数器，是线程私有的，就是一个指针，指向方法区的方法字节码(用来存储指向下一条指令的地址，也就是即将要执行的指令代码)，在执行引擎读取下一条指令。
- 方法区是被所有线程共享的，所有字段和方法字节码，以及一些特殊方法，如构造函数，接口代码也在此定义。简单说，所有定义方法的信息都保存在这个地方，这个区域是一个共享区域。**静态变量，常量，类信息(构造方法，接口定义)、Class、运行时的常量池存在方法区，但是实力变量存储堆内存，与方法区无关**



**重点：**栈：主管程序的运行，线程结束栈内存也就释放了

为什么main方法先执行，最后结束：JVM栈是空的，代表程序未开始或已结束，main方法是在最下面的。

什么东西放在栈：8大基本类型+对象引用+实例的方法

栈运行原理：栈帧(就是对应执行的每个方法)，每个栈帧包括：方法索引、输入输出参数、本地变量、ClassFile引用、父帧指向和子帧指向

栈满：StackOverflowError



栈+堆+方法区交互：







堆：

Heap，一个JVM只有一个堆内存，堆内存的大小是可以调节的

OOM：OutOfMemoryError，Java堆内存满

遇到OOM：

1.  尝试扩大堆内存再运行看结果
2. 如果还是出现了OOM，则需要分析代码，看看哪里出现了问题(JPofiler)

三个区域：

- 新生区：
  - 是一个类诞生，成长甚至死亡的地方
  - 分为伊甸园区、幸存0区和幸存1区(动态的，to和from)
  - GC回收主要针对就是伊甸园区和养老区
  - 幸存区幸存下来就在养老区，没有幸存下来就被gc
- 养老区：
- 永久区：JDK1.6之前叫做永久代，常量池在方法区；JDK1.7也叫永久代，但是慢慢退化了，常量池在堆中；JDK1.8叫做元空间，常量池在元空间中。不存在GC，关闭JVM就会被释放。

**内存中新生区+养老区=堆内存空间，永久区逻辑上存在，物理上不存在**



GC：垃圾回收的区域只有在堆和方法区，方法区就在堆里面

JVM进行GC时，并不是对这三个区域统一回收，大部分时候回收都是新生代

- 新生代：
- 幸存区：
- 老年区：

GC两种类：轻GC(miner gc)、重GC(full gc)

问题：

- JVM的内存模型和分区，详细到每个区放什么
- 堆里面的分区有哪些？
- GC的算法：标记清除法，标记压缩，复制算法，引用计数器，怎么用？
- 轻GC和重GC分别在什么时候发生

四种算法：

- 引用计数法
- 复制算法（**新生代gc主要用的是复制算法**）：
  - 我们假设两个幸存区分别为幸存0区和幸存1区，刚开始都为空。伊甸园满了之后触发gc。
  - 每次gc都会将伊甸园中活的对象移到幸存0区或幸存1区，我们假设此时移入幸存0区。此时伊甸园为空。此时我们把幸存0区叫做from区，1区叫做to区。
  - 伊甸园又满了触发第二次gc。如果有活的对象进入另外一个空的幸存区，即幸存1区。此时则把原来幸存0区的元素复制到幸存1区，幸存0区为空。此时幸存1区为from区，幸存0区为to区。
  - 当一个对象经历了15次gc之后还没被清除，则进入老年代。该阈值`MaxTenuringThreshold`可以被调整。注：伊甸园区放不下，触发轻gc放到幸存区，幸存区放不下放到老年区，老年区放不下触发重gc，重gc没有用出OOM
  - 复制算法保证其中有一个幸存区为空；复制算法适合存活率较低的地方：新生区
  - 好处：不会有碎片化
  - 坏处：需要额外的空间
- 标记清除算法：如何判断存活：引用计数？可达性算法？
  - 好处：不需要额外的空间
  - 坏处：会产生内存碎片，两次扫描严重浪费时间
- 标记压缩算法：标记清除的优化，
  - 压缩：再次扫描，向一端移动存活的对象，防止内存碎片的产生
  - 好处：不会产生内存碎片
  - 坏处：多一次移动成本

### GC总结：

内存效率：复制算法>标记清除>标记压缩

内存整齐度：复制算法=标记压缩>标记清除

内存利用率：标记压缩算法=标记清除算法>复制算法

思考一个问题：有没有最优算法

答案：没有，没有最好的算法，只有最合适的算法，不同的场景下有最合适的算法！

分代收集算法：

- 年轻代：存活率低，复制算法
- 老年代：区域大，存活率高，标记清除+标记压缩混合实现(JVM调优：几次清除后进行压缩)



JMM：java Memory Model

 









